<!doctype html>
<html class="theme-next use-motion ">
<head>
  

<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />








  <link rel="stylesheet" type="text/css" href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5"/>



  
    <link href='//fonts.lug.ustc.edu.cn/css?family=Lato:300,400,700,400italic&subset=latin,latin-ext' rel='stylesheet' type='text/css'>
  


<link rel="stylesheet" type="text/css" href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" />

<link rel="stylesheet" type="text/css" href="/css/main.css?v=0.4.5.2"/>


    <meta name="description" content="Think without help" />



  <meta name="keywords" content="Hexo,next" />





  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=0.4.5.2" />


<meta name="description" content="Think without help">
<meta property="og:type" content="website">
<meta property="og:title" content="Tink">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Tink">
<meta property="og:description" content="Think without help">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Tink">
<meta name="twitter:description" content="Think without help">


<script type="text/javascript" id="hexo.configuration">
  var CONFIG = {
    scheme: '',
    sidebar: 'post'
  };
</script>



  <title> Tink </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  <!--[if lte IE 8]>
  <div style=' clear: both; height: 59px; padding:0 0 0 15px; position: relative;margin:0 auto;'>
    <a href="http://windows.microsoft.com/en-US/internet-explorer/products/ie/home?ocid=ie6_countdown_bannercode">
      <img src="http://7u2nvr.com1.z0.glb.clouddn.com/picouterie.jpg" border="0" height="42" width="820"
           alt="You are using an outdated browser. For a faster, safer browsing experience, upgrade for free today or use other browser ,like chrome firefox safari."
           style='margin-left:auto;margin-right:auto;display: block;'/>
    </a>
  </div>
<![endif]-->
  






  <div class="container one-column 
   page-home 
">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">Tink</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu ">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div id="content" class="content"> 
  <section id="posts" class="posts-expand">
    
      

  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                <a class="post-title-link" href="/2016/01/09/goodbay-2015/" itemprop="url">
                  一五一十
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            发表于
            <time itemprop="dateCreated" datetime="2016-01-09T19:28:33+08:00" content="2016-01-09">
              2016-01-09
            </time>
          </span>

          

          
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <blockquote class="blockquote-center"><p>2015一年来的叨逼叨</p>
</blockquote>
<p>往年的年终总结, 更像一个todoList, 今年搭建了自己的博客, 也确实发生了许多事, 值得写一篇文章回顾一下, 想到哪说到哪吧.</p>
<h1 id="Book">Book</h1><p>往年跨年了, 我会简单地查看下一年下来看了多少书, 各属于什么领域, 读得怎么样. 去年书读得要比往年稍少一些, 今年可能会更少些. </p>
<p>大学四年, 我计划每年一百本, 四年读满四百本. 当时定下这个计划, 可能是因为看了俞敏洪的鸡汤文, 他大学看了八百本, 我这已经打了对折. 读到第二年, 我就转变了策略, 数量其实是没有意义的, 俗话说贪多嚼不烂, 空费时间罢了. 豆瓣上不是有人一年看一千多本么, 但大多数都没有什么质量. </p>
<p>去年的时候, 我就开始有意思地选取自己真正感兴趣和想要长期研究的领域, 认真地调研, 为搭建自己的知识架构, 搜集相关的书目. 在这个过程中, 我发现, 入门一个新的领域, 看书总是比直接搜集资料要慢, 越是新兴的事物越是如此. 一本优秀的入门书, 总是优秀的, 但是横向比较不同媒介, 其时间性价比效用正在随着互联网资料的发达逐渐消减. 买书, 借书也都是成本, 随手搜个博文, 总是更快. 现在我总是更倾向于先搜索一下, 对这个领域的知识架构有个基本的了解, 再去找为各个分支准备一些专门的读物. 而入门书的作用, 更像是一种补充.</p>
<p>读书的功力, 经过这几百本的修炼, 实在没有太大的长进, 只怪自己愚钝. 唯有阅读的习惯, 总算是养成了. 上半年当然还是文学书读得较多, 原计划是阅读些拉美文学, 马尔克斯、博尔赫斯、聂鲁达、略萨、鲁尔福、科塔萨尔等等, 拉了一个很长的作家名单, 但只读了半个博尔赫斯, 戛然而止. 实训, 论文, 实习, 接踵而至, 到了下半年, 就以科幻小说和技术书居多了.</p>
<p>去年的年初, 我写了一个总的大纲, 大意是按照一个文学爱好者, 空气笔作家的路线拟的, 主要分学习写作和写作素材两大部分. 技术类书籍原定就一本<code>Thinking in Java</code>. 一年晃过来, 我连java都不搞了, 蛤蛤. </p>
<p>今年的时间不像过去两年那么多, 离400本的目标也只剩下20本, 在6月前达标, 总算是圆满的. <code>Just do it</code>的哲学我是一直没有学会的, 写作这种私人化的活动, 通过参照他人的经验, 很难说在未有实践之前, 会有很大的启发意义. 当然美国大学中的创意写作课程, 认为写出优秀的小说, 这是一个有范式的活动. 我以为, 要是以后者为思路, 再重读一遍<code>故事</code>即可, 今年要做的, 便是动起笔来.</p>
<h1 id="Code">Code</h1><p>去年一整年写的代码, 大概比我往年所有写过的代码加起来还要多, 毕竟去年以前, 我也不怎么写代码. 人生总是有许多幻想, 一开始幻想成为别人, 后来又幻想成为未来的自己, 最好还能回到以前, 让以前的自己放弃幻想, 早点醒悟.</p>
<p>一切都源于兴趣的驱动, 尤其感谢NodeJS, 算是搭上了JS社区的顺风车. 有一种说法是, 班里毕业时, 混得最不好的那批人才去做前端, 先不说这话是否属实, 其实前端相较于其它平台, 是最符合<code>flow theory</code>心流体验的, do-(failed-redo-)success, 更直观和有趣的正反馈循环.</p>
<ul>
<li>学py或java, 第一开始只能print, 学得慢的, print了一个礼拜就失去兴趣了. 而前端则是编写UI的, 做出几个页面显然更有意思些.</li>
</ul>
<ul>
<li>你要说Android和iOS开发也可以看到页面的话, 那前端的另一个好处是无需安装环境, 只需要有一个记事本和浏览器就好了.</li>
</ul>
<p>基于这两点, 如果有人只是想要学编程而无所谓领域的话, 学习前端来入门可能是最好的.</p>
<p>在学习JS之前, 我有诸多恐慌, 这种恐慌在我为了Unity学习C#之前也有, 但是C#和Java是如此之像, 以至于我从来不敢说我新学了一门语言, 我只不过是在用写Java的思路写C#罢了. 但JS并不允许我这样. 从一个Java新手跳跃为JS新手, 其实并没有什么损失, 反而让我深刻地体验到, 相较于不同语言, 开发时所面向的相关问题域更值得关注. 不同场景下, 面临的环境不同, 需要满足的需求往往也不同, 其开发模式自然便有了根本的差异, 这并不是换一个语言就能解决的问题, 而是所有语言在此场景下需要共同面对的元命题. 而切入不同的业务, 即算在相同的环境下, 编程思路也要发生改变.</p>
<p>语言自然有它自己本身的哲学, 不过我去年的问题在于, 对于语言本身的哲学理解得并不通透, 对开发时面向的问题域, 也没有足够的认识. 理想的措施是, 在摸清问题域的情况下, 因地制宜地, 尽可能符合语言的哲学, 但不要尝试逆天而行, 为了符合某种语言风格, 无视问题域, 增加问题复杂度.</p>
<p>故今年的学习思路分两条, 一是语言的实现及其哲学, 二是所要解决的问题域. 这两样都是编程的内功.</p>
<p>去年做了几个玩具项目, 比如, </p>
<ul>
<li>用于Unity的C#行为树框架, 写得有点问题, 但大致OK.</li>
</ul>
<ul>
<li>一个<code>MongoDB</code>+<code>Express</code>+<code>Angular</code>+<code>NodeJS</code>MEAN的仿微博应用.</li>
</ul>
<ul>
<li>一个查词用<code>chrome</code>扩展</li>
</ul>
<p>本来想好好谈谈, 但想说的太多, 也分别总结过, 一时竟无语凝噎. 这些项目的问题在于<code>just a demo</code>, 完全不是生产环境下的产品, 只是学习产物. 对于我本人而言, 也意味着缺乏项目经验. 这只能从实习中去学了.</p>
<h1 id="Career">Career</h1><p>12月月底, 也就是上个礼拜, 我拿到了<strong>shanbay</strong>的offer, 开始为期半年的实习生工作. 在面试前, shanbay先发了一个小作业, 即上面谈到的查词插件, 说实话, 我花了很长时间, 做得也不够好. 一周后面试, 我竟然还迟到了, 这让我很尴尬, 我抱着多点面试经验的心情做完了面试题, 参与了技术面, 然后裹挟着自我嫌恶之情畏缩在床铺里发呆. 我没有想到几天后, 竟还能拿到offer, 这是我第一次面试, 而且还是一次我自己来评价, 都难以称得上满意的面试, 结果是在意料之外的. </p>
<p>然接踵而来的便是入职, 一周的工作, 效率低, 表现差, 疲惫之余, 更多的是紧张. 我知道, 欠下的技术债, 总是要还的.</p>
<p>别的不多说, Hello 2016.</p>

            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                <a class="post-title-link" href="/2015/11/30/amway-gitbook/" itemprop="url">
                  Gitbook
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            发表于
            <time itemprop="dateCreated" datetime="2015-11-30T17:36:41+08:00" content="2015-11-30">
              2015-11-30
            </time>
          </span>

          

          
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <blockquote class="blockquote-center"><p>文艺码农的铜版纸</p>
</blockquote>
<h1 id="Gitbook">Gitbook</h1><p>今天学习React的时候, 读到一份官方文档的<a href="https://hulufei.gitbooks.io/react-tutorial/content/introduction.html" target="_blank" rel="external">中文版</a>, 阅读界面简洁大方, 跟我用的这个博客主题有些类似.<br><img src="https://ooo.0o0.ooo/2015/10/30/56339754c6dbf.png" alt="gitbook效果.png" title="gitbook效果"></p>
<p>看了一下它的域名, 发现并不是xx.github.io, 而是xx.gitbooks.io. 也就是说, 不是通过github pages构建的, 查过以后发现, gitbook并不是github推出的一款服务, 尽管他们长得很像, 操作类似, 理念相同, 显然gitbook inspired by github.</p>
<p>Gitbook的官网是<a href="https://www.gitbook.com/@tink/dashboard" target="_blank" rel="external">GitBook.com</a>. 其实9月份我刚进去的时候, 样子还不是现在这样, 大概就是10月到11月之间UI改版了一次, 搞得跟github简直可以说是一模一样… 连notification气泡的样式都像素级相似.<br>Gitbook主打在线协作共同写作, 这理念是继承了github的开源精神. 种类很多, 比如在它的热门项目里, 有台北市长柯文哲用该工具写的书(噗). 不过总的还是以技术书籍居多, 比如<a href="https://www.gitbook.com/book/numbbbbb/-the-swift-programming-language-/details" target="_blank" rel="external">《The Swift Programming Language》中文版</a>.</p>
<p>对于普通玩家来说, 就算不懂git也没关系, gitbook提供了全平台的客户端编辑器, 学习下markdown语法就可以写成自己的电子书. 像我就比较爱折腾, 还有点电子洁癖, 懒得多下一个软件占地方.<br>Gitbook另外一个好处就是, 可以允许书籍连接某个github仓库, 一旦有新的commit被push到仓库, 对应的书籍就会自动更新.</p>
<p>我觉得, 如果要成体系地整理知识, 以书的形式来展现可能要比东一篇西一篇的博文来得好, 有些琐碎的东西也不方便放进博客, 显得很水的样子. 从阅读体验上来说, 带目录的电子也比较好.</p>
<h1 id="特点">特点</h1><p>除了利用git, 同步github仓库以外, gitbook对于程序员用户来说还有下面几个优势:</p>
<ul>
<li>使用的是md语法, 仅就基础样式就很简洁方便</li>
<li>直接生成在线网站, 相当于免费主页, 还支持下载.pdf, .epub, .mobi</li>
<li>支持绑定其它域名</li>
<li>提供了命令行工具</li>
<li>还有不少的插件, 官方提供了dev-api, 有余力的可自行开发</li>
</ul>
<p>导出为epub这点倒是蛮好的, 可以下载一本他人写好的技术书然后放进多看慢慢看.</p>
<h1 id="快速入门">快速入门</h1><p>GitBook可以通过npm安装命令行工具, 不过我刚摆弄这玩意儿的时候, 没有从官网的文档上找到命令行的命令介绍, 所以就通过使用网站完成了基础的操作.</p>
<p>第一步, 直接注册, 验证通过后, 在<code>Your Profile</code>中, 关联GitHub账号.<br>第二步, 选择新建书籍,在选项卡里选择关联事先在GitHub新建的仓库.<br><img src="https://ooo.0o0.ooo/2015/10/30/563384f9396ba.png" alt="gitbook关联github的仓库.png" title="新建book, 并关联github的仓库, 实现同步"><br>之后, 就完成了GitHub的关联, 默认生成了如下文件<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">默认生成的文件目录</span><br><span class="line">book/</span><br><span class="line">├── README.md  		// 书籍简介</span><br><span class="line">├── chapter1.md 	// 章节文件</span><br><span class="line">└── SUMMARY.md 	 	// 书籍的目录结构</span><br><span class="line"></span><br><span class="line">目录结构文件book/SUMMARY.md</span><br><span class="line"><span class="bullet">* </span>[<span class="link_label">First Chapter</span>](<span class="link_url">chapter1.md</span>)</span><br><span class="line"></span><br><span class="line">成形的常见的目录结构是这样的</span><br><span class="line">├── chapter1</span><br><span class="line">│   ├── README.md</span><br><span class="line">│   ├── section1.md</span><br><span class="line">│   └── section2.md</span><br><span class="line">├── chapter2</span><br><span class="line">│   ├── README.md</span><br><span class="line">│   ├── section1.md</span><br><span class="line">│   └── section2.md</span><br><span class="line">├── end</span><br><span class="line">│   └── README.md</span><br><span class="line">├── README.md</span><br><span class="line">└── SUMMARY.md</span><br><span class="line"></span><br><span class="line">其SUMMARY.md则为</span><br><span class="line"><span class="bullet">* </span>[<span class="link_label">简介</span>](<span class="link_url">README.md</span>)</span><br><span class="line"><span class="bullet">* </span>[<span class="link_label">第一章</span>](<span class="link_url">chapter1/README.md</span>)</span><br><span class="line"> - [<span class="link_label">第一节</span>](<span class="link_url">chapter1/section1.md</span>)</span><br><span class="line"> - [<span class="link_label">第二节</span>](<span class="link_url">chapter1/section2.md</span>)</span><br><span class="line"><span class="bullet">* </span>[<span class="link_label">第二章</span>](<span class="link_url">chapter2/README.md</span>)</span><br><span class="line"> - [<span class="link_label">第一节</span>](<span class="link_url">chapter2/section1.md</span>)</span><br><span class="line"> - [<span class="link_label">第二节</span>](<span class="link_url">chapter2/section2.md</span>)</span><br><span class="line"><span class="bullet">* </span>[<span class="link_label">结束</span>](<span class="link_url">end/README.md</span>)</span><br></pre></td></tr></table></figure></p>
<p>简单提下, 这个SUMMARY.md文件是一个内容组织文件, gitbook通过读取这个文件来生成目录. 从md语法的角度来说, 是一堆嵌套的链接列表.</p>
<h1 id="进阶">进阶</h1><p>其实网上的快速入门教程不少, 不过由于改版的关系, 有些操作逻辑过时了, 好在大差不差, 官方文档没找到的情况下, 看着前人的资料也算是深入摆弄成功了.<br>我把参考放在了文末的References中, 这里提下我自己趟过的雷区.</p>
<ul>
<li>npm命令行工具从 <code>npm install -g gitbook</code>改为了<code>npm install -g gitbook-cli</code>. 如果装错, 需先卸载前者.</li>
<li>在对应目录下键入<code>gitbook serve</code>命令, 就可以通过localhost:4000 预览生成的以网页形式组织的书籍.</li>
<li>如果绑定的仓库名改名了. 那对应的绑定也要改名, 同时还得通过<code>add webhooks</code>去先删除旧的hook, 添加新的hook.</li>
</ul>
<h1 id="缺点">缺点</h1><p>从国内访问GitBook比较慢, 我看到好多书都并不以xx.gitbooks.io开头, 而是移到了国内. 好在gitbook是支持绑定域名的, 所以速度敏感的话, 可以参考资料进行迁移. 也有教程是介绍发布到GitHub Pages的.</p>
<h1 id="ChangeLog">ChangeLog</h1><ul>
<li>12-05<br>最近我把为知笔记里的内容稍作了整理, 放到了gitbook上, 删掉了之前的项目lol, 书籍地址请戳<a href="https://tink.gitbooks.io/fe-collections/content/index.html" target="_blank" rel="external">我的前端手册</a></li>
</ul>
<h1 id="References">References</h1><ul>
<li><a href="http://www.chengweiyang.cn/gitbook/index.html" target="_blank" rel="external">GitBook简明教程</a><br>这篇讲到了集成GitHub, <a href="http://www.chengweiyang.cn/gitbook/gitbook.com/config/domain.html" target="_blank" rel="external">绑定域名</a>, <a href="http://www.chengweiyang.cn/gitbook/github-pages/README.html" target="_blank" rel="external">发布到GitHub Pages</a>.</li>
<li><a href="http://blog.csdn.net/xiaocainiaoshangxiao/article/details/46882921" target="_blank" rel="external">gitbook安装与使用</a><br>这篇有讲到输出pdf的出错和解决办法</li>
</ul>

            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                <a class="post-title-link" href="/2015/11/12/modularity/" itemprop="url">
                  JS模块化
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            发表于
            <time itemprop="dateCreated" datetime="2015-11-12T21:42:35+08:00" content="2015-11-12">
              2015-11-12
            </time>
          </span>

          

          
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <blockquote class="blockquote-center"><p>JS模块化的历史演进、ES6 Module和模块管理工具</p>
</blockquote>
<p>像我这种从java入门编程的人, 在学习java的时候, 可能对模块化并没有太多的认识, 因为java中一个类一个文件, 引用其他类只需<code>import</code>导入, 结构十分清晰. 就像人每时每刻都在呼吸空气, 对空气的感觉并没有那么敏感, 直到有人抽走了他周身的空气, 他才会感觉将要窒息. 是的, 就好像我玩起了Node, 立志做个前端(此处应有表情).</p>
<p>在前端, 起初这里根本就没有什么模块化, 再后来, 我发现这里存在着各种各样的实现方法, 真是官方逼死同人哇. 这让原本习惯写后端的我感觉有些头疼, 原来我以为所有的编程语言都自带模块化标准呢.</p>
<p>“模块化Modularity”模块化显然是软件工程的概念, 就像我开头提到的, java中通过类来组织模块, 其核心就是封装-&gt;复用. 对于大型应用来说, 将整个系统拆分为不同模块, 有助于简化设计工作. 这么来看, js一开始确实没有模块化的需求, 因为原本只是在浏览器里跑两行脚本而已, 谁也没想到它竟会像今天一样变得如此复杂庞大, 以至于现在流行SPA啦, 大前端啦, 老黄历就明显不够用了. 有人说脚本语言不需要模块化, 但我接触过python, python也支持模块化, 所谓脚本语言超过1000行就没法管理了纯粹是对开发人员的鄙视, 瓦们要分清矛盾的主次.</p>
<p>那么js加上模块化就能轻松管理1000行以上的代码吗? 我想可以应该可以吧, 我写js也不久, 通过写一个Node项目给我的感觉是, 还好, 准确来说, 还挺爽的. 在NodeJS中通过在文件写一大堆类似于<code>var mongoose = require(&#39;mongoose&#39;);</code>的导入声明, 再以<code>module.exports</code>导出, 体验相对良好, 而且这属于Node的规范(下文会提到, 准确地说是实现了一部分CommonJS规范), 初学时套一套Java的做法, 并不是很难理解.</p>
<p>那么前端呢? 好消息是, ES6已经支持了类似import这样的语法, 我们应该使用babel转换器, 现在就使用它.</p>
<p>不过, 在那之前, 我们来看看, ES6之前, 大家是怎么实现模块化的. 如果你是第一次尝试模块化, 可以快速跳过AMD/CMD规范之争(即跳着看第三部分: 最近一波模块化规范), 因为他们已经过时了.</p>
<h1 id="文章的结构">文章的结构</h1><ul>
<li>模块化的好处: 为什么要模块化?</li>
<li>传统的模块化解决方案</li>
<li>最近一波模块化规范</li>
<li>ES6 Module</li>
<li>前端模块管理工具</li>
</ul>
<h1 id="模块化的好处">模块化的好处</h1><p>对应到前端, 如果前端也模块化了, 起码有这样几个好处:</p>
<ul>
<li>可重用</li>
<li>解决命名冲突的问题</li>
<li>解决繁琐的文件依赖</li>
</ul>
<h2 id="命名冲突">命名冲突</h2><p>多人团队的时候, 往往有一些个工具类, 需要用到的时候引入文件即可. 但如果现在要实现一个和工具类中同名的方法, 就会引起冲突.<br>最低级的做法, 定义一个不同的名字.</p>
<p>YUI2参考了java中<strong>命名空间</strong>的思想, 它是这样解决这个问题的:<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> com = &#123;&#125;;</span><br><span class="line">com.tinkblog = &#123;&#125;;</span><br><span class="line">com.tinkblog.utils = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">com.tinkblog.utils.getJob = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>完美地解决了冲突, 而且引起了java程序员的亲切感. 但等一段时间以后, 我们就会发现, 每次想使用这个方法, 就得记住长长的命名空间(这已经算短的了…), 比如这样:<br><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 代码来自Yahoo!</span><br><span class="line"><span class="keyword">if</span> (org.cometd.Utils.<span class="built_in">isString</span>(response)) &#123;</span><br><span class="line">  <span class="keyword">return</span> org.cometd.JSON.fromJSON(response)<span class="comment">;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (org.cometd.Utils.<span class="built_in">isArray</span>(response)) &#123;</span><br><span class="line">  <span class="keyword">return</span> response<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="文件依赖">文件依赖</h2><p>一般地, 文件之间常有依赖关系, 比如bootstrap依赖于jquery, 那么如果缺少jquery, bootstrap就会有问题<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">script</span> <span class="attribute">src</span>=<span class="value">"jquery.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">script</span> <span class="attribute">src</span>=<span class="value">"bootstrap.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>这属于众所周知的依赖, 万一是自己写的, 那就没那么容易让所有人都知道这些依赖关系啦. 而且一旦被依赖的库更新了, 依赖它的库可能都要挂掉…<br>目前在解决依赖和版本管理这个问题上, 在后端我是使用npm来管理的, 在前端则使用过一段时间的bower, 当然现在来说, bower都停止维护啦, 已经打算通过webpack+npm来管理前端的包管理.</p>
<h1 id="传统的模块化解决方案">传统的模块化解决方案</h1><p>在目前主流的模块化风格提出之前, 还有个好多种模块化方式, 出于回顾历史的需要, 不妨简单看看.</p>
<h2 id="简单地封装成一个函数">简单地封装成一个函数</h2><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">m1</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">m2</span><span class="params">()</span></span>&#123;</span><br><span class="line">　<span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种做法只是把一组变量和函数放进两个不同的函数, 利用函数作用域来形成”模块”.<br>缺点:</p>
<ul>
<li>无法保证不与其他”模块”发生变量名冲突</li>
<li>污染全局变量</li>
<li>模块成员之间缺乏联系</li>
</ul>
<h2 id="封装成一个对象">封装成一个对象</h2><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> module1 = &#123;</span><br><span class="line">  _count : <span class="number">0</span>,</span><br><span class="line">　m1 : <span class="function"><span class="keyword">function</span> <span class="params">()</span></span>&#123;</span><br><span class="line">　  <span class="comment">//...</span></span><br><span class="line">　&#125;,</span><br><span class="line">　m2 : <span class="function"><span class="keyword">function</span> <span class="params">()</span></span>&#123;</span><br><span class="line">　　<span class="comment">//...</span></span><br><span class="line">　&#125;</span><br><span class="line">&#125;;</span><br><span class="line">module1.m1();</span><br><span class="line">module2.m2();</span><br></pre></td></tr></table></figure>
<p>一个对象一个模块, 变量名不再冲突, 使用的时候, 就调用对象的属性,<br>缺点:</p>
<ul>
<li>暴露了所有模块成员, 比如外部代码可以通过module._count来改变内部计数器, 而_count一般是希望模块私有的</li>
<li>可能会使模块调用变得很长长长长长长</li>
</ul>
<h2 id="立即执行函数">立即执行函数</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> module1 = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> _count = <span class="number">0</span>;</span><br><span class="line">　<span class="keyword">var</span> m1 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">　  <span class="comment">//...</span></span><br><span class="line">　&#125;;</span><br><span class="line">　<span class="keyword">var</span> m2 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">　　<span class="comment">//...</span></span><br><span class="line">　&#125;;</span><br><span class="line">　<span class="keyword">return</span> &#123;</span><br><span class="line">　　m1 : m1,</span><br><span class="line">　　m2 : m2</span><br><span class="line">　&#125;;</span><br><span class="line">&#125;());</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(module1._count); <span class="comment">//undefined</span></span><br></pre></td></tr></table></figure>
<p>立即执行函数Immediately-Invoked Function Expression, 充分利用了函数作用域和闭包的概念, 比起简单地封装为一个对象, _count进一步变为私有成员.<br>为什么function外面还要包一层()? 因为不写的话, js会将关键字function解析为函数声明语句(参考js预编译原理), 而非函数定义表达式.</p>
<p>这种形式也是js模块化的基本写法, 受到了蝴蝶书和犀牛书的推荐, github上很多开源代码都采用了这种写法. 以下的做法都是基于它的变形.</p>
<h2 id="模块扩展augmentation">模块扩展augmentation</h2><p>一个模块继承另一个模块<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> module1 = (<span class="function"><span class="keyword">function</span> <span class="params">(mod)</span></span>&#123;</span><br><span class="line">　mod.m3 = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">　　<span class="comment">//...</span></span><br><span class="line">　&#125;;</span><br><span class="line">　<span class="keyword">return</span> mod;</span><br><span class="line">&#125;(module1));</span><br></pre></td></tr></table></figure></p>
<p>上述代码返回一个新的模块module1. 其中m3是新增的方法, 则mod是被继承的模块.</p>
<p>提到继承, 就顺便提到重载, js中通过改变加载顺序即可实现.<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> module1 = (<span class="function"><span class="keyword">function</span> <span class="params">(mod)</span></span>&#123;</span><br><span class="line">  <span class="keyword">var</span> oldM4 = mod.m4;</span><br><span class="line">　mod.m4 = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">　　<span class="comment">// 重载m4, 通过oldM4, 还可以调用旧方法</span></span><br><span class="line">　&#125;;</span><br><span class="line">　<span class="keyword">return</span> mod;</span><br><span class="line">&#125;(module1));</span><br></pre></td></tr></table></figure></p>
<p>在浏览器环境中, 各个模块通常是从网上获取的, 有时无法知道哪个部分会先加载, 则可能加载到一个undefined.<br><strong>松耦合扩展loose augmentation</strong>仅仅使用短路, 让立即执行函数的参数可以为一个空对象.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> module1 = (<span class="function"><span class="keyword">function</span> (<span class="params">mod</span>)</span>&#123;</span><br><span class="line">　mod.m3 = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">　　<span class="comment">//...</span></span><br><span class="line">　&#125;;</span><br><span class="line">　<span class="keyword">return</span> mod;</span><br><span class="line">&#125;(<span class="built_in">window</span>.module1 || &#123;&#125;));</span><br></pre></td></tr></table></figure></p>
<h2 id="引入全局变量">引入全局变量</h2><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> module1 = (<span class="function"><span class="keyword">function</span> <span class="params">($)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 在此处使用jquery对象</span></span><br><span class="line">&#125;(jQuery));</span><br></pre></td></tr></table></figure>
<p>为了在模块内调用全局变量, 必须显式地输入变量, 这种方式使得模块间的依赖关系更清晰.</p>
<p>好了, 以上回顾了传统的模块化开发方式, 即文件拆分、解决全局变量污染、命名空间和私有等等, 接下来再谈谈模块化的规范.</p>
<h1 id="最近一波模块化规范">最近一波模块化规范</h1><p>规范仅起到约束作用, 即要求大家用同样的方式编写模块, 适合开源项目或团队开发. 事实上在ES56 Module还没有出来以前, 这块是相当热闹的, 前端主要以CommonJS, AMD, CMD这三种标准为主.<br>由于我入门比较晚, 当我打算玩前端模块化的时候, 这一领域可以说几乎快要决出胜负了. 所以我对除了CommonJS以外的这些规范也只是了解而已, 并未实用, 可见的未来也应该用不上了.</p>
<h2 id="CommonJS">CommonJS</h2><p>CommonJS原来叫ServerJS, 正如其名, 由于Node.js采用并实现了部分规范, ServerJS才广泛流行.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 由于 Node 原生支持模块的作用域，并不需要额外的 wrapper</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="built_in">require</span>(<span class="string">'./a'</span>)  <span class="comment">// 加载模块（同步加载）</span></span><br><span class="line">a.doSomething()         <span class="comment">// 等上一句执行完才会执行</span></span><br><span class="line"></span><br><span class="line">exports.b = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="comment">// 暴露 b 函数接口</span></span><br><span class="line">  <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面是Node的实现, <code>exports</code>、<code>require</code>都是内置加载函数, 分别对应导出api和引入api. 使用<code>module.exports</code>直接导出一个模块(对象)</p>
<p>ServerJS大获成功, 社区希望将其推广至前端, 并改名为CommonJS. 但CommonJS存在着一些问题. 采用同步加载的机制, 这对服务器环境来说, 硬盘I/O速度不是问题, 然而放到浏览器环境, 网速就不给力了.</p>
<h2 id="分流">分流</h2><p>为了解决这个问题, 社区开始分化, 逐渐发展出三个流派, 它们分别是</p>
<ul>
<li>Modules/1.x</li>
</ul>
<p>这个观点觉得 1.x 规范已经够用, 只要移植到浏览器端就好. 要做的是新增 Modules/Transport 规范, 即在浏览器上运行前, 先通过转换工具将模块转换为符合 Transport 规范的代码.<br>主流代表是服务端的开发人员. 现在值得关注的有两个实现: 越来越火的 component 和走在前沿的 es6 module transpiler.</p>
<ul>
<li>Modules/Async</li>
</ul>
<p>这个观点觉得浏览器有自身的特征, 不应该直接用 Modules/1.x 规范.<br>典型代表是 AMD 规范及其实现 RequireJS.</p>
<ul>
<li>Modules/2.x</li>
</ul>
<p>2.x 认为也不能直接套到浏览器环境, 但应该尽可能与 Modules/1.x 规范保持一致.<br>这个观点下的典型代表是 BravoJS 和 FlyScript 的作者. BravoJS 作者对 CommonJS 的社区的贡献很大, 对 Modules/2.0-draft 规范花了很多心思. FlyScript 的作者提出了 Modules/Wrappings 规范, 这规范是 CMD 规范的前身. 后来这两人都没有继续推进这一流派, 在国外基本死得差不多了, 反而在国内有玉伯的sea.js, 虽然在我整理这篇文章的时候, 玉伯已经宣布了sea.js已死.</p>
<p>总体来看, 呈现两条主要道路, 即</p>
<ul>
<li>AMD的RequireJS: 异步加载, 预执行, 依赖前置</li>
<li>CMD的SeaJS: 异步加载, 懒执行, 依赖就近, 推荐CommonJS写法</li>
</ul>
<h2 id="AMD_&amp;_RequireJS">AMD &amp; RequireJS</h2><p>RequireJS实现了一套模块化标准, 即<code>Async Module Definition</code>, 在浏览器环境中异步加载模块. 它基本上已经成为目前的主流规范, 但是随着ES5 Module的出现, 局面也仍未定.<br>它通常长成这样:<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义calculator（计算器）模块</span></span><br><span class="line">define(</span><br><span class="line">  <span class="string">'calculator'</span>,     <span class="comment">// 可选, 模块名, 通常匿名</span></span><br><span class="line">  [<span class="string">'adder'</span>],        <span class="comment">// 可选, 模块的依赖项</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span><span class="params">(adder)</span> </span>&#123; <span class="comment">// 为模块执行初始化, 并返回具有add方法的匿名对象</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      add: <span class="function"><span class="keyword">function</span><span class="params">(n1, n2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 实际调用的是adder（加法器）模块的add方法, 而且adder模块已在前一参数['adder']中指明了</span></span><br><span class="line">        <span class="keyword">return</span> adder.add(n1, n2);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>AMD的核心是<code>define</code>函数, 这个函数用于定义一个模块, 它传入三个参数, 模块名, 依赖项和返回该模块定义的工厂函数.<br>这种风格就是AMD写法, 我们可以看到, 它是<strong>依赖前置</strong>的, 即, 要在开头就写上所有的依赖项.</p>
<p>这当然有点麻烦, 后来AMD引入了CommonJS语法糖, 可以貌似依赖就近啦.<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>([<span class="string">'math'</span>], <span class="function"><span class="keyword">function</span> <span class="params">(math)</span></span> &#123;</span><br><span class="line">  <span class="built_in">math</span>.add(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p><code>require</code>函数用于动态加载依赖项, 它的第一个参数是一个数组, 数组元素即要加载的模块. 第二个参数是一个回调, 加载模块后被执行. 模块的加载不影响它后面语句的运行, 所有依赖这个模块的语句, 都定义在一个回调函数中, 等到加载完成再执行回调.</p>
<p>它的实现其实是这样的:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">define([<span class="string">'require'</span>, <span class="string">'dependency1'</span>, <span class="string">'dependency2'</span>], <span class="function"><span class="keyword">function</span> (<span class="params">require</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> dependency1 = <span class="built_in">require</span>(<span class="string">'dependency1'</span>),</span><br><span class="line">        dependency2 = <span class="built_in">require</span>(<span class="string">'dependency2'</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>这里引出了AMD的一个问题, 即<strong>执行时机</strong>有争议.</p>
<p>在Modules/1.0中<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">var</span> <span class="tag">a</span> = <span class="function"><span class="title">require</span><span class="params">(<span class="string">"./a"</span>)</span></span> <span class="comment">// 执行到此时，a.js 才同步下载并执行</span></span><br></pre></td></tr></table></figure></p>
<p>在AMD中使用 require 的语法糖时<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">define([<span class="string">"require"</span>], <span class="function"><span class="keyword">function</span>(<span class="params">require</span>))</span>&#123;</span><br><span class="line">  <span class="comment">// 在这里，a.js 已经下载并且执行好了</span></span><br><span class="line">  <span class="comment">// 使用 require() 并不是 AMD 的推荐写法</span></span><br><span class="line">  <span class="keyword">var</span> a = <span class="built_in">require</span>(<span class="string">"./a"</span>) <span class="comment">// 此处仅仅是取模块 a 的 exports</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>AMD 里提前下载 a.js 是出于对浏览器环境的考虑, 只能采取异步下载, 这个社区都认可(Sea.js 也是这么做的).<br>但是 AMD 的执行是 <strong>预执行(Early Executing)</strong>, 而 Modules/1.0 是第一次 require 时才执行. 这个差异很多人不能接受, 包括持 Modules/2.0 观点的人也不能接受.</p>
<p>抛开require不谈, 毕竟AMD<strong>不推荐使用require</strong>. 针对预执行导致破坏依赖就近这一问题, require2.x开始思考异步处理<strong>软依赖</strong>的方案来解决<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数体内：</span></span><br><span class="line"><span class="keyword">if</span>(status)&#123;</span><br><span class="line">  <span class="keyword">async</span>([<span class="string">'a'</span>],<span class="function"><span class="keyword">function</span>(<span class="params">a</span>)</span>&#123;</span><br><span class="line">    a.doSomething()</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="CMD_&amp;_SeaJS">CMD &amp; SeaJS</h2><p>SeaJS实现了另一套模块化标准, 即<code>Common Module Definition</code>, 它也是异步加载, 但尽量遵循CommonJS的风格. 虽然这个思想不是SeaJS首先提出的, 但SeaJS之前在国内还是比较火的, 毕竟玉伯老师有淘宝光环. 但据老师本人微博(大概今年8月间), 他已经亲手给SeaJS送过丧了.</p>
<p>CMD支持的语法和CommonJS类似, 它更推荐使用<code>require</code>函数, 但是也吸收了不少AMD的思想. 比如, 根据Module/2.x的最初风格, 即 FlyScript 中的 的模块定义api 叫做 module.declare, SeaJS为了能够匹配AMD风格, 改名为 define, 传入的参数也和RequireJS相同.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params">require, exports</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="built_in">require</span>(<span class="string">'./a'</span>);   <span class="comment">// 获取模块 a 的接口</span></span><br><span class="line">  a.doSomething();          <span class="comment">// 调用模块 a 的方法</span></span><br><span class="line">  exports.foo = <span class="string">'bar'</span>;      <span class="comment">// 对外提供 foo 属性 和 doSomething 方法</span></span><br><span class="line">  exports.doSomething = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>require和exports都是全局函数, 风格与CommonJS一致.</p>
<p>比较CMD和AMD, 一大不同是CMD是<strong>依赖就近</strong>的, 因为在实现上, 它是<strong>懒执行</strong>的.<br>我们回顾下AMD的define函数:<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">define([<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>], <span class="function"><span class="keyword">function</span><span class="params">(a, b, c)</span></span>&#123;</span><br><span class="line">  <span class="comment">// 提前申明了并初始化了所有模块</span></span><br><span class="line">  <span class="literal">true</span> || b.foo(); <span class="comment">//即便根本没用到模块 b，但 b 还是提前执行了。</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>然后是CMD的:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params">require, exports, module</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="built_in">require</span>(<span class="string">'./a'</span>)</span><br><span class="line">  a.doSomething()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> b = <span class="built_in">require</span>(<span class="string">'./b'</span>) <span class="comment">// 依赖就近，延迟执行</span></span><br><span class="line">  b.doSomething()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<h2 id="UMD_&amp;_ES6_Module_Transpiler">UMD &amp; ES6 Module Transpiler</h2><p>es6 module transpiler 开发组称自己为<a href="http://zhuanlan.zhihu.com/FrontendMagazine/19569085" target="_blank" rel="external">UMD</a><code>Universal Module Definition</code>). 它希望提供一个前后端跨平台的解决方案, 同时支持CommonJS和AMD.</p>
<p>它的实现思路是这样的:</p>
<ul>
<li>先判断是否支持Node.js模块格式(exports是否存在), 存在则使用Node.js模块格式.</li>
<li>再判断是否支持AMD(define是否存在), 存在则使用AMD方式加载模块.</li>
<li>前两个都不存在，则将模块公开到全局(window或global)</li>
</ul>
<p>UMD的提出者声称, 这是对于应对规范之争的无奈之举, 写到这里, 我也感觉很无奈…</p>
<p>因为在过去几个月间, 有相当多的工具都在相继宣告go die, 以知乎等社区的推荐来看, 大家都倾向于直接使用ES6, 抛弃SeaJS(CMD)和RequireJS(AMD).</p>
<h1 id="ES6_Module">ES6 Module</h1><p>随着babel这等工具的推进, ES6的推进将比之前的版本都要快. 而且加入到语言规范中的的特性, 往往将在未来成为趋势, 所以尽快学习很有必要.</p>
<p>不过ES6 Module还在变化之中, 这里仅仅只能初涉, 具体细节等到spec确定下来, 再进一步补充完善吧.</p>
<p>ES6 Module尽量并不是UMD, 但它还是尽量在兼容现有的AMD和CommonJS模块, 支持导入这两者的模块. 它要更优雅一些, 它有所超越, 原生的语法和关键字也更方便. 最近, ES6去掉了module和loader关键字, 整体更趋向于简洁, 一个模块跟普通的脚本看起来差别不大. 你只要注意:</p>
<ul>
<li>ES6 模块<strong>自动开启严格模式</strong></li>
<li>在模块中使用import和export导入导出</li>
<li>模块中声明的任何成员都是私有的, 必须使用export来暴露它们</li>
</ul>
<h2 id="export_&amp;_import_导出和导入">export &amp; import 导出和导入</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">detectCats</span>(<span class="params">canvas, options</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> kittydar = <span class="keyword">new</span> Kittydar(options);</span><br><span class="line">  <span class="keyword">return</span> kittydar.detectCats(canvas);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">Kittydar</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 该函数未经export, 是私有的</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resizeCanvas</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="comment">//  ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>export可以添加在<code>function</code>, <code>class</code>, <code>var</code>, <code>let</code>或<code>const</code>之前. 当然, 如果觉得一一导出相当麻烦, 可以使用<strong>导出表</strong>特性, 只写一行, 导出一个变量列表:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> &#123;detectCats, Kittydar&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 尽管没有export 前缀, 依旧被导出</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">detectCats</span>(<span class="params">canvas, options</span>) </span>&#123; ... &#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Kittydar</span> </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure></p>
<p>通过一个ES6模块, 我们无需将模块内的代码放进一个立即执行函数中了. 模块不再是一个脚本文件, 它的生命周期被封装进模块作用域中, 不再会有跨文件跨模块的全局变量. 并且, 我们依旧可以访问一些基本的全局变量.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;detectCats, Kittydar&#125; <span class="keyword">from</span> <span class="string">"kittydar.js"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">go</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> canvas = <span class="built_in">document</span>.getElementById(<span class="string">"catpix"</span>);  <span class="comment">// 访问了全局变量document</span></span><br><span class="line">  <span class="keyword">var</span> cats = detectCats(canvas);</span><br><span class="line">  drawRectangles(canvas, cats);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>import导入模块, 在运行时, 被引入的模块会先被导入, 加载, 再根据依赖, 对每一个模块的内容进行深度优先遍历, 并跳过已经执行过的模块, 避免依赖循环.</p>
<h2 id="as_重命名">as 重命名</h2><p>和CommonJS一样, ES6 Module也支持允许对导入的对象重命名, 只需使用<code>as</code>关键字<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;flip <span class="keyword">as</span> flipOmelet&#125; <span class="keyword">from</span> <span class="string">"eggs.js"</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;flip <span class="keyword">as</span> flipHouse&#125; <span class="keyword">from</span> <span class="string">"real-estate.js"</span>;</span><br></pre></td></tr></table></figure></p>
<p>类似的, 导出变量也可以重命名. 这允许你将同一个值或对象以不同的变量名导出两次.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">v1</span>(<span class="params"></span>) </span>&#123; ... &#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">v2</span>(<span class="params"></span>) </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> &#123;</span><br><span class="line">  v1 <span class="keyword">as</span> streamV1,</span><br><span class="line">  v2 <span class="keyword">as</span> streamV2,</span><br><span class="line">  v2 <span class="keyword">as</span> streamLatestVersion</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="default_默认导出">default 默认导出</h2><p>理解了重命名之后, 对于导入我们还可以有一些简写, 如<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> _ <span class="keyword">from</span> <span class="string">"lodash"</span>;</span><br></pre></td></tr></table></figure></p>
<p>这等价于<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;default <span class="keyword">as</span> _&#125; <span class="keyword">from</span> <span class="string">"lodash"</span>;</span><br></pre></td></tr></table></figure></p>
<p>其中, <code>default</code>对应的是ES6模块一个默认的导出, 可以说它主要还是为了支持那些还没有ES6化的CommonJS模块, 导出它们的exports对象. 在ES6中也可以写自己的默认导出:<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">export</span> <span class="tag">default</span> &#123;</span><br><span class="line">  <span class="attribute">field1</span>: value1,</span><br><span class="line">  <span class="attribute">field2</span>: value2</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="*_模块对象">* 模块对象</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> cows <span class="keyword">from</span> <span class="string">"cows"</span>;</span><br></pre></td></tr></table></figure>
<p>通过import *, 被引入进来的是一个 <code>module namespace object</code>, 它的属性是那个模块的导出. 所以如果 “cows” 模块导出了一个名为 moo() 的函数，通过上面的那种导入方式就可以cows.moo()来调用.</p>
<h2 id="export_from_聚合模块">export from 聚合模块</h2><p>有时候一个包的主模块会引入许多其他模块, 然后再将它们以一个统一的方式导出. 为了简化这样的代码, ES6提供了 import-and-export 的简写：<br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// main.js</span><br><span class="line"><span class="keyword">export</span> &#123;<span class="type">Tea</span>, <span class="type">Cinnamon</span>&#125; <span class="keyword">from</span> <span class="string">"sri-lanka"</span>;</span><br><span class="line"><span class="keyword">export</span> &#123;<span class="type">Coffee</span>, <span class="type">Cocoa</span>&#125; <span class="keyword">from</span> <span class="string">"equatorial-guinea"</span>;</span><br><span class="line"><span class="keyword">export</span> * <span class="keyword">from</span> <span class="string">"singapore"</span>;</span><br></pre></td></tr></table></figure></p>
<p>这种 export-from 的表达式和真正的导入不同, 它有隐患. 它并不会在作用域中<strong>加入二次导出的变量绑定</strong>. 所以如果需要在 main.js 中写用到了 Tea 的代码, 就别使用这个简写形式.<br>如果 “singapore” 导出的某一个变量恰巧和其他的导出变量名冲突了, 那么这里就会出现一个错误. 所以应该谨慎使用 export *。</p>
<h2 id="模块加载的细节">模块加载的细节</h2><p>大致来说, 当 JS 引擎运行一个模块的时候, 它的行为大致可归纳为以下四步:</p>
<ul>
<li>解析: 阅读模块的源码, 并且检查是否有语法错误.</li>
<li>加载: (递归地) 加载所有被引入的模块. (  <em>还未标准化</em>  )</li>
<li>链接: 为每个新加载的模块创建一个作用域, 并且将模块中的声明绑定填入其中, 包括从其他模块中引入的.</li>
</ul>
<p>综上, 其实js引擎并不会执行import语句, 而是预编译. 模块代码运行之前, import的处理过程已经完成, 执行到一行import声明的时候, 什么也不会发生. 这意味着, <strong>ES6更倾向于AMD的预执行而不是CMD的懒执行</strong>.<br>为此, 它还有更多限制:</p>
<ul>
<li>import 和 export 只能写在顶级作用域中, 我们无法在<strong>条件语句</strong>中使用引入和导出, 也不能在<strong>自己写的函数作用域</strong>中使用import</li>
<li>所有的导出必须显示地指定一个变量名</li>
<li>无法通过一个循环动态地引入一堆变量</li>
<li>对于 import 错误, 无法在运行时进行恢复, 这导致一个应用中的任何一个加载失败或链接失败, 这个应用就不会运行. 同时无法在 try/catch 语句中 import.</li>
<li>模块无法控制它的依赖是如何被加载的, 所以无法hook一个模块, 然后在它被加载之前运行一些别的代码</li>
</ul>
<p>这一切都是因为预执行的特性, 这说明, ES6 Module是相当静态的, 这真是刷新三观哪. 但是正是基于此, 我们可以使用webpack在预处理时就检测出错误.</p>
<h1 id="前端模块管理工具">前端模块管理工具</h1><p>光有模块化, 我们还得有模块管理工具, 毕竟不同模块之间, 尤其是开源库之间, 版本管理是件麻烦事.<br>RequireJS和SeaJS各自都实现了自己的模块规范和加载器, 但还足以被称为前端模块管理器, 后者一般包括:</p>
<ul>
<li>npm + browserify</li>
<li>npm + webpack</li>
<li>bower</li>
<li>spm</li>
<li>component.js</li>
<li>duo.js</li>
</ul>
<p>下面仅对我使用过的几个简单说说.</p>
<h2 id="npm">npm</h2><p>npm属于Node模块的管理器, 支持的是CommonJS风格, 一般用于后端. 优势是库多, 应该说, 一个库一旦流行, 一定会提供npm install. 一般来说, 前端并不会直接使用npm. 而是搭配browserify一起使用.<br>browserify本身并不是一个模块管理工具, 它只是让服务器端的CommonJS格式的模块可以运行在浏览器端, 相当于间接为前端提供npm管理功能. webpack则功能更强大, 不仅能实现browserify的功能, 甚至还可以打包css, 图片等更多的资源, 和babel配合默契, 已然成为下一代主流工具.</p>
<h2 id="bower">bower</h2><p>bower是Twitter推出的包管理工具, 规范中立(UMD), 这导致它曾是最流行的前端包管理工具. 它不提供构建工具, 本质是一个静态资源的共享平台. 现在已经<strong>死啦</strong>.</p>
<p>bower与npm非常类似, 通过<code>bower i</code>来下载安装包. 比起npm和spm, bower并没有将模块发布者的文件打包保存到自己的服务器, 也没有保存模块的版本信息, 而是让发布者通过注册的形式, 公开模块可访问的git地址, 记录到bower的服务器中. 安装的过程就是根据git地址clone一份到用户本地的bower_components中.<br>bower可以通过bower.json进行版本和依赖管理, 可以通过.bowerrc文件对bower_components文件夹的位置进行指定.</p>
<h2 id="我的比较">我的比较</h2><p>对于我来说, 我一开始用的bower, 也只是做包管理, 没有进行打包的经验, bower也不提供这样的功能, 为此我不得不在index.html中写上密密麻麻的script标签来引入模块.<br>后来我接触了<strong>npm+webpack</strong>方案, 发现更合我的胃口, 因为我先玩的Node, 自然对npm和CommonJS规范感觉更亲切. 而且, 当使用Node作为后端时, 下载的包前后端通用. 开发上我用webpack进行打包, 给出一个入口文件, 不用考虑html上的script标签及其加载顺序, 那本身就已经写在了package.json中.</p>
<h1 id="总结">总结</h1><p>前端技术发展很快, 工具层出不穷, 它们往往以低廉的代价专注于某个问题域给出了当时合理的解决方案, 在短时间内成为主流, 但往往由于标准的推进, 前端问题域的变化, 落后于更好的解决方案, 迅速过时.<br>这启发我对于学习前端, 始终坚持这样一种策略:</p>
<ul>
<li>对新生工具和技术, 防御性地跟进了解, 作为技术储备</li>
<li>对主流的解决方案, 分析调研目前的需求, 快速使用, 作为开发技能</li>
<li>对过时的流行方案, 观察当时出现的背景和对应的问题域, 研究其核心思想, 作为分析参考</li>
</ul>
<p>就目前来说, 我觉得学习ES6很有必要, 这无疑是趋势, 而且现在用babel之类的转换器, 成本相当低, 带来的开发收益则很大. 但问题是, ES6的部分标准, 比如Module, 仍处于变化中, 所以并不适合大量采用.<br>2015年年末, 前端模块化的最佳实践还是npm + webpack, 即CommonJS风格. 等到Node对ES6支持得更好了, 到时再全面转过去.</p>
<h1 id="References">References</h1><ul>
<li><a href="https://github.com/seajs/seajs/issues/547" target="_blank" rel="external">前端模块化开发的价值| 玉伯</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2012/10/javascript_module.html" target="_blank" rel="external">JavaScript模块化编程| 阮一峰</a></li>
<li><a href="https://github.com/seajs/seajs/issues/588" target="_blank" rel="external">前端模块化开发那点历史| 玉伯</a></li>
<li><a href="http://huangxuan.me/2015/05/25/js-module-loader/" target="_blank" rel="external">JavaScript Module Loader</a></li>
<li><a href="http://justineo.github.io/singles/writing-modular-js/" target="_blank" rel="external">使用 AMD、CommonJS 及 ES Harmony 编写模块化的 JavaScript</a></li>
<li><a href="http://segmentfault.com/a/1190000003410285" target="_blank" rel="external">ES6 的模块系统</a></li>
<li><a href="http://zhuanlan.zhihu.com/FrontendMagazine/20238288" target="_blank" rel="external">知乎专栏: ECMAScript 6 模块架构| 来自前端外刊评论</a></li>
<li><a href="http://www.zhihu.com/question/24414899" target="_blank" rel="external">知乎: npm、spm、bower 这三个包管理器，哪个比较好用？| 来自倪云建的回答</a></li>
</ul>
<h1 id="changeLog">changeLog</h1><ul>
<li>15-11-21<br>更新了SeaJs的<a href="http://www.zhihu.com/question/34756861" target="_blank" rel="external">讣告</a><br>更新了bower的讣告</li>
<li>15-12-07<br>重写了前端模块化管理工具的部分, 去掉了没有用过的工具的过多的介绍, 将webpack写成一篇新的文章.<br>新增了ES6 Module的内容</li>
</ul>

            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                <a class="post-title-link" href="/2015/10/25/js-scope/" itemprop="url">
                  让我们一层一层地剥开作用域
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            发表于
            <time itemprop="dateCreated" datetime="2015-10-25T08:31:25+08:00" content="2015-10-25">
              2015-10-25
            </time>
          </span>

          

          
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <blockquote class="blockquote-center"><p>为什么我的眼中常含泪水? 是洋葱, 布兰登·艾克在js里放了洋葱…</p>
</blockquote>
<p>js中变量的作用域, 只有全局作用域和<strong>函数作用域</strong>, 不支持类C语言中的块级作用域(一个花括号即一个作用域.)</p>
<p>全局作用域没什么好讲的, 全局变量有全局作用域. 下面主要讲函数作用域.</p>
<h1 id="表现">表现</h1><p>定义在函数内部的变量和参数, 在函数外部不可见, 在函数内部任何位置的变量则在函数内任何位置都可见.</p>
<h1 id="实现">实现</h1><p>js通过<strong>作用域链Scope Chain</strong>来实现作用域, 与C不同, js的作用域链不是基于栈而是基于列表的.</p>
<p>1  当定义一个函数时, 将该时刻的作用域链连接到这个函数对象的<strong>[[scope]]</strong>属性.<br>[[scope]]是一个内部属性, 仅供js引擎访问, 它包含了函数被创建的作用域中的对象的集合.</p>
<p>2  当调用这个函数时, 会创建一个叫<strong>执行时上下文(execution context)</strong>的内部对象, 它定义了函数执行时的环境.<br>每个执行时上下文都会有自己的作用域链用于标识符解析, 这个作用域链先是被初始化当前执行函数的[[scope]]中所包含的所有对象, 然后再将一个新创建的叫<strong>活动对象(activation object)</strong>的对象推入到作用域链的最前端.<br>活动对象中包含了函数的所有局部变量, 命名参数, 参数集合和this.</p>
<p>当执行时上下文被销毁, 活动对象也随之销毁.</p>
<p>3  在发生标识符解析(或称<strong>变量解析variable resolution</strong>)的时候, 就逆向查询当前作用域链的每一个活动对象的属性.<br>如果找到同名的就返回, 找不到, 那就是这个标识符没有被定义, 抛出ReferenceError.</p>
<h2 id="用实例表述">用实例表述</h2><h3 id="定义时刻">定义时刻</h3><ul>
<li>创建[[scope]]属性, 收集保存作用域内的被创建的对象.</li>
<li>把[[scope]]属性链接到作用域链</li>
<li>设置[[scope]]属性指向的活动对象(本例为全局活动对象window activation object)</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params">arg1, arg2</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> mood = arg1 + arg2;  <span class="comment">// 调试点1</span></span><br><span class="line">  <span class="keyword">var</span> moha = makeABigNews();</span><br><span class="line">  moha();  <span class="comment">// 调试点4</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeABigNews</span>(<span class="params"></span>)</span>&#123; <span class="comment">// 调试点2</span></span><br><span class="line">  <span class="keyword">var</span> mood = <span class="string">'angry!'</span>;</span><br><span class="line">  <span class="keyword">var</span> result = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="comment">// 调试点3</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'I am '</span> + mood);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="调用时刻">调用时刻</h3><ul>
<li>创建activeObj(假设名)活动对象, 同时创建arguments属性.</li>
<li><p>以保存为属性的形式, 将函数的每一个<strong>形参</strong>和<strong>局部变量</strong>添加到活动对象中</p>
<p>比如activeObj.arg1, activeObj.arg2, activeObj.prop</p>
</li>
<li>把实参赋给形参</li>
<li>把activeObj活动对象作为作用域链最前端</li>
<li>把fun函数的[[scope]]属性所指向的活动对象(假设在浏览器中的话, 本例为window activation object)也加入到作用域链</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调试点0</span></span><br><span class="line"><span class="function"><span class="title">fun</span><span class="params">('excited', '!')</span>; <span class="comment">// I am angry!</span></span></span><br></pre></td></tr></table></figure>
<h3 id="图表展示流">图表展示流</h3><p>1  定义时<br><img src="https://ooo.0o0.ooo/2015/12/05/56639d1fafd6e.png" alt="定义时作用域链"></p>
<p>2  执行时<br><img src="https://ooo.0o0.ooo/2015/12/05/5663b3a43220f.png" alt="执行时作用域链"></p>
<h2 id="调试追踪">调试追踪</h2><p>还以上面的代码为例, 配合chrome-devtool, 查看作用域链的变化, 讲讲为什么最终输出<code>I am angry!</code>.</p>
<p>调试点的编号也指明了调试时解释跳转的顺序.</p>
<p>1  当调用fun函数的时候, 其作用域链是由{window activation object}-&gt;{activeObj}组成的.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 刚刚进入fun函数, 即源码处的调试点1</span></span><br><span class="line">[[scope chain]] = [</span><br><span class="line">&#123;</span><br><span class="line">     <span class="built_in">arguments</span>: [<span class="string">'excited'</span>, <span class="string">'!'</span>],</span><br><span class="line">     arg1: <span class="string">'excited'</span>,</span><br><span class="line">     arg2: <span class="string">'!'</span>,</span><br><span class="line">     mood: <span class="literal">undefined</span>,</span><br><span class="line">     moha: <span class="literal">undefined</span></span><br><span class="line">&#125;, &#123;</span><br><span class="line">     <span class="built_in">window</span> activation object</span><br><span class="line">&#125;]</span><br></pre></td></tr></table></figure>
<p>2  当调用进入makeABigNews的函数体的时候, 此时makeABigNews的作用域链为</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 对应调试点<span class="number">2</span></span><br><span class="line">[[scope chain]] = [</span><br><span class="line">&#123;</span><br><span class="line">     mood: undefined,</span><br><span class="line">     <span class="literal">result</span>: undefined</span><br><span class="line">&#125;, &#123;</span><br><span class="line">     window activation <span class="keyword">object</span></span><br><span class="line">&#125;]</span><br></pre></td></tr></table></figure>
<p>3  在定义result函数的时候, result函数的scope为</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 对应调试点<span class="number">3</span></span><br><span class="line">[[scope chain]] = [</span><br><span class="line">&#123;</span><br><span class="line">     mood: 'angry!',</span><br><span class="line">     <span class="literal">result</span>: undefined</span><br><span class="line">&#125;, &#123;</span><br><span class="line">     window activation <span class="keyword">object</span></span><br><span class="line">&#125;]</span><br></pre></td></tr></table></figure>
<p>4  从makeABigNews函数返回以后, 在fun函数中调用result的时候, 发生了标识符解析, 而此时的作用域链为</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 对应调试点<span class="number">4</span></span><br><span class="line">[[scope chain]] = [</span><br><span class="line">&#123;</span><br><span class="line">     <span class="literal">result</span> call <span class="keyword">object</span></span><br><span class="line">&#125;, &#123;</span><br><span class="line">     mood: 'angry!',</span><br><span class="line">     <span class="literal">result</span>: undefined</span><br><span class="line">&#125;, &#123;</span><br><span class="line">     window activation <span class="keyword">object</span></span><br><span class="line">&#125;]</span><br></pre></td></tr></table></figure>
<p>可以看到, 这时候并不包含fun的活动对象, 所以返回的是makeABigNews活动对象中的mood属性.</p>
<h2 id="特例">特例</h2><p>通过构造器创建的函数是访问不到外层的局部变量的.</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">var</span> func = <span class="keyword">new</span> <span class="function"><span class="keyword">Function</span><span class="params">(<span class="string">"console.log(typeof i);"</span>)</span></span>;</span><br><span class="line">    func(); <span class="comment">// undefined</span></span><br><span class="line">&#125;</span><br><span class="line">outer();</span><br></pre></td></tr></table></figure>
<h1 id="总结">总结</h1><ul>
<li>在定义函数时, 就决定了函数的scope属性, 其作用域也在那时被确定下来.</li>
<li>由于逆向查找, 标识符所在位置越深, 读写越慢, 所以少用全局变量.</li>
<li>一个跨作用域的变量被引用了一次以上, 那么最好把它变成局部变量再使用.</li>
</ul>
<h1 id="Todo">Todo</h1><ul>
<li>ES6中的模块作用域</li>
<li>ES6中的let带来的块级作用域</li>
</ul>
<h1 id="References">References</h1><ul>
<li><a href="http://www.cnblogs.com/lhb25/archive/2011/09/06/javascript-scope-chain.html" target="_blank" rel="external">JavaScript 开发进阶：理解 JavaScript 作用域和作用域链</a></li>
<li><a href="http://www.laruence.com/2009/05/28/863.html" target="_blank" rel="external">Javascript作用域原理 by laruence</a></li>
</ul>

            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                <a class="post-title-link" href="/2015/09/18/the-way-to-build-my-blog/" itemprop="url">
                  Hello World
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            发表于
            <time itemprop="dateCreated" datetime="2015-09-18T20:02:55+08:00" content="2015-09-18">
              2015-09-18
            </time>
          </span>

          

          
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <blockquote class="blockquote-center"><p>在世界的中心呼唤爱</p>
</blockquote>
<h1 id="为什么要开博客">为什么要开博客</h1><p>现在社交网站流行, 玩博客的其实只剩下程序员和一些非主流了. 而玩这种非社交类博客的, 更是少之又少, 基本除了爱折腾的程序员就没别人了.<br>我之前用过Lofter, 社区氛围不错, 博客的浏览量也还行, 版式算是我用过的博客中最好看的. 文青时代的我还使用过豆瓣日记, 写了不少小说. 有一天心血来潮打开了本地保存的副本, 吓得我赶紧从床上跳下来把这些丢人的玩意儿全删了. 更远古的QQ日志就不谈了, 像我们这么文艺的少年为了bigger, 高中的时候就关闭了空间.</p>
<p>做程序员并不是一件早已打算的事情, 刚上大学那会儿我还是想成为一名作家, 业余也好, 写一些严肃的不媚俗的文字. 耕纸细作也罢, 仅止于记录也好, 没有停止过写字. 事实证明这并不算是无用功, 这段时间磨砺出来的阅读和写作的习惯, 使我在编程一事上受益良多.<br>比如, 比起视频, 我更爱直接看文档, 确实这样也更快些. 看的时候也禁不住要打开编辑器记下来, 像在纸上圈圈点点一般标记一番, 画出小说的线索, 厘清知识间的线性关系. 最后再排个版. 看起来虽然蛮花工夫发, 但我以为这有助于记忆的固化, 好比内存不够就把日志系统搞得完善些存在硬盘里.</p>
<p>然而, 仅仅是记录还不够, 如果要成体系地理解一个知识原理, 使用费曼学习法记忆效果更高, 这要求我将我所学习的知识, 以尽可能让人快速理解的方式写出来. 实践中, 写博客可能是最好的.</p>
<p>关于选什么博客, 本来考虑过博客园, csdn, 简书以及旁的什么小站, 但前两者对markdown支持得还不够好, 简书什么的, 又不太喜欢那边的氛围, 最后还是选择在github上建立一个github page了, 提交也方便些.</p>
<h1 id="GithubPages_&amp;_Hexo">GithubPages &amp; Hexo</h1><p>github的个人博客建立起来很简单, 只需要将仓库名设置成username.github.io, 再在仓库里放进静态网页的代码就ok了, 访问username.github.io这个域名时, 它会自动读取仓库中的index.html. 理论上, 只要提供对应的css和js, 能生成一个漂亮的页面.</p>
<p>不过作为尝鲜, 我还是从简单的形式开始, 使用了hexo作为构建工具. 在此之前看了jelly等其他工具, 不过hexo是基于npm的, 当时我正好在学习nodejs, 颇感亲切, 毫不犹豫地选用了.</p>
<p>hexo使用起来基本没什么难度, 简单的几行命令就帮助我完成了所有的工作.</p>
<ul>
<li><code>hexo new &#39;title&#39;</code></li>
</ul>
<p>新建一个名为<code>title</code>的博文, 其实它只是在<code>source/_posts</code>文件下新建了一个md文件. 所以一般我不用这个命令, 直接在该文件夹下新建.md文件. 不过命令生成的文件会在开头自带标题和日期, 像是这样<br><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">title: "Hello World"</span><br><span class="line">date: 2015-9-18 20:02:55</span><br><span class="line"><span class="header">tags:</span><br><span class="line">---</span></span><br></pre></td></tr></table></figure></p>
<ul>
<li><code>hexo server</code></li>
</ul>
<p>打开localhost:4000实时预览生成的页面</p>
<ul>
<li><code>hexo generate</code></li>
</ul>
<p>读取source目录下的_posts文件夹, 然后生成html和对应的css, js文件到<code>.deploy_git</code>文件夹中. 如果把favicon.ico图片也放到source文件夹下, hexo就会读取到这个名称的文件, 把它作为博客的标签页图标.</p>
<ul>
<li><code>hexo deploy</code></li>
</ul>
<p>部署博客, 把<code>.deploy_git</code>文件下的内容提交到绑定的仓库中</p>
<p>这四个指令非常简单, 配好git就能使用.</p>
<p>关于样式, 我用的是<code>NexT</code>主题, 引用来源已经标注在了博客的页脚. 使用主题的一点好处是, 免去了自己写css的麻烦, 而且这套主题真的蛮简约精致的, 我很喜欢.</p>
<p>稍显瑕疵的是, 块与块之间的间距稍微难看, 比如说标题和文段之间, 文段和图片之间. 我本人也比较喜欢在中文输入法下使用英文标点, 以免写程序的时候出现不必要的麻烦, 博客里显示出来就有点不太美观了. 大标题小标题之间的字号也差异过小.<br>诶, 有时间一定得调整哈. 要是能顺便改个自己的主题出来, 当然更好啦.</p>
<h1 id="markdown编辑器">markdown编辑器</h1><p>早期的时候, 我跟着知乎上的建议, 摆弄过印象笔记, 为知笔记, 以及诸如此类的种种笔记类产品. 为知笔记我现在还用着, 但我觉得它有些繁琐, 写到一半总要照顾样式. 编辑模式下和阅读模式下, 有些格式存在显示差异, 这让我很烦躁.<br>后来我发现了<code>markdown</code>, 并尝试用markdown来进行一切文档写作, 我才有了那么一丝快意. markdown解放了我在编写时的心智负担, 至少让我把注意力重新放回内容本身了. 而markdown整个格式本身就很适合解析到html, hexo选择了markdown, 也是我选择hexo的一部分原因.</p>
<p>为知笔记当然也是支持markdown的, 但是支持得还不够好. 随着记录的东西越来越多, 为知打开越来越慢, 直接利用windows资源管理器打开更快, 更方便管理, 找东西更快(没错, 为知的文件管理是一个很大的槽点…). 所以原生态的本地md编辑器更适合我. 我试用了在线编辑器, 这不太好, 我还是想在本地写作. cmd markdown我用了将近一个月, 在线的体验非常好, pc版是用nw技术构建的, 所以几乎和网页版一致. 问题在于, 并不能同步地编辑我本地的文件.</p>
<p>目前我一般用vs code写markdown, UI总体还算不错的, 编辑器内分屏, 可以实现一般markdown编辑器左边写作, 右边实时预览的功能. 但是高亮不太好, 也不支持导出html, 当然也不可能支持多端同步. 总之比起mac上的mou来说真的差远了.</p>
<p>说真的, 我倒是想自己写一个markdown编辑器, 并且有了一点思路, 比如markdown渲染的解析可能需要一些编译原理的知识, vs code 也开源了, 寒假的时候我打算看下parser方面的知识, 着手实现一个.</p>
<h1 id="图床">图床</h1><p>在编写md文档的时候, 文章里的图片其实都是链接, 语法是<code>![图片名](外链网址 &quot;图片描述&quot;)</code>.<br>一般来说, 写文章用到的图片, 很多是临时做的图, 没法使用现成的图片外链. 所以需要将图片上传到网络上的某处空间, 并返回一个外链以供使用.<br>这种专门用于存储图片的空间, 又叫做图床. 国内有很多免费的图床, 以图床为关键字, 随便百度一下, 一抓一大把. 在国内其实主要还是以申请<code>七牛</code>或者<code>又拍</code>的账号, 利用刚注册的那十多个G的空间做图床, 其速度很快的.</p>
<p>不过像我们这种懒人, 肯定是使用免费免注册的图床啦. 在这里推荐一个亲测好用的良心图床</p>
<p><a href="#https://sm.ms/">sm.ms</a>.</p>
<p>看这个名字就知道, 这是<code>V2EX</code>的一个绅♂士做的一个图床. 据说能够达到无损. 每张图片最大5M, 支持gif.<br>速度上, 本博客的所有图片都是来自sm.ms的, 也足够称得上极快.</p>
<p>至于使用方法相当简单, 上传图片, 然后会生成外链和各种格式的引用.<br><img src="https://ooo.0o0.ooo/2015/10/30/563365ec6aa27.png" alt="sm.ms的输出外链和引用" title="sm.ms的输出外链和引用"><br>想要验证sm.ms图片显示速度的, 顺便可以刷新下页面看看加载的效果.<br>PS. 这张图是用QQ截图截的, 可能本身就会有点糊, 要看是否无损, 还是比较下博客里其它的图片吧.</p>
<h1 id="changelog">changelog</h1><ul>
<li>15-12-05<br>更新了markdown编辑器一节</li>
</ul>

            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  

 </div>

        

        
      </div>

      
        
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      <section class="site-overview">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" src="https://avatars3.githubusercontent.com/u/8469791?v=3&s=460" alt="Tink" itemprop="image"/>
          <p class="site-author-name" itemprop="name">Tink</p>
        </div>
        <p class="site-description motion-element" itemprop="description">Think without help</p>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">5</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          <div class="site-state-item site-state-categories">
            
              <span class="site-state-item-count">0</span>
              <span class="site-state-item-name">分类</span>
              
          </div>

          <div class="site-state-item site-state-tags">
            <a href="/tags">
              <span class="site-state-item-count">3</span>
              <span class="site-state-item-name">标签</span>
              </a>
          </div>

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        <div class="links-of-author motion-element">
          
        </div>

      </section>

      

    </div>
  </aside>


      
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner"> <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="icon-next-heart fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Tink</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT
  </a>
</div>


 </div>
    </footer>

    <div class="back-to-top"></div>
  </div>

  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  
  
    
    

  


  
  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js"></script>
  <script type="text/javascript" src="/js/fancy-box.js?v=0.4.5.2"></script>


  <script type="text/javascript" src="/js/helpers.js?v=0.4.5.2"></script>
  

  <script type="text/javascript" src="/vendors/velocity/velocity.min.js"></script>
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js"></script>

  <script type="text/javascript" src="/js/motion_global.js?v=0.4.5.2" id="motion.global"></script>




  <script type="text/javascript" src="/js/nav-toggle.js?v=0.4.5.2"></script>
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  

  <script type="text/javascript">
    $(document).ready(function () {
      if (CONFIG.sidebar === 'always') {
        displaySidebar();
      }
      if (isMobile()) {
        FastClick.attach(document.body);
      }

      motionIntegrator.bootstrap();
    });
  </script>

  
  

  
  

  
  <script type="text/javascript" src="/js/lazyload.js"></script>
  <script type="text/javascript">
    $(function () {
      $("#posts").find('img').lazyload({
        placeholder: "/images/loading.gif",
        effect: "fadeIn"
      });
    });
  </script>
</body>
</html>
