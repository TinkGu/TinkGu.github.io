<!doctype html>
<html class="theme-next use-motion ">
<head>
  

<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />








  <link rel="stylesheet" type="text/css" href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5"/>



  
    <link href='//fonts.lug.ustc.edu.cn/css?family=Lato:300,400,700,400italic&subset=latin,latin-ext' rel='stylesheet' type='text/css'>
  


<link rel="stylesheet" type="text/css" href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" />

<link rel="stylesheet" type="text/css" href="/css/main.css?v=0.4.5.2"/>


    <meta name="description" content="Think without help" />



  <meta name="keywords" content="js," />





  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=0.4.5.2" />


<meta name="description" content="JS模块化的历史演进、ES6 Module和模块管理工具

像我这种从java入门编程的人, 在学习java的时候, 可能对模块化并没有太多的认识, 因为java中一个类一个文件, 引用其他类只需import导入, 结构十分清晰. 就像人每时每刻都在呼吸空气, 对空气的感觉并没有那么敏感, 直到有人抽走了他周身的空气, 他才会感觉将要窒息. 是的, 就好像我玩起了Node, 立志做个前端(此处应有">
<meta property="og:type" content="article">
<meta property="og:title" content="JS模块化">
<meta property="og:url" content="http://yoursite.com/2015/11/12/modularity/index.html">
<meta property="og:site_name" content="Tink">
<meta property="og:description" content="JS模块化的历史演进、ES6 Module和模块管理工具

像我这种从java入门编程的人, 在学习java的时候, 可能对模块化并没有太多的认识, 因为java中一个类一个文件, 引用其他类只需import导入, 结构十分清晰. 就像人每时每刻都在呼吸空气, 对空气的感觉并没有那么敏感, 直到有人抽走了他周身的空气, 他才会感觉将要窒息. 是的, 就好像我玩起了Node, 立志做个前端(此处应有">
<meta property="og:updated_time" content="2015-12-08T09:24:37.400Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="JS模块化">
<meta name="twitter:description" content="JS模块化的历史演进、ES6 Module和模块管理工具

像我这种从java入门编程的人, 在学习java的时候, 可能对模块化并没有太多的认识, 因为java中一个类一个文件, 引用其他类只需import导入, 结构十分清晰. 就像人每时每刻都在呼吸空气, 对空气的感觉并没有那么敏感, 直到有人抽走了他周身的空气, 他才会感觉将要窒息. 是的, 就好像我玩起了Node, 立志做个前端(此处应有">


<script type="text/javascript" id="hexo.configuration">
  var CONFIG = {
    scheme: '',
    sidebar: 'post'
  };
</script>



  <title> JS模块化 | Tink </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  <!--[if lte IE 8]>
  <div style=' clear: both; height: 59px; padding:0 0 0 15px; position: relative;margin:0 auto;'>
    <a href="http://windows.microsoft.com/en-US/internet-explorer/products/ie/home?ocid=ie6_countdown_bannercode">
      <img src="http://7u2nvr.com1.z0.glb.clouddn.com/picouterie.jpg" border="0" height="42" width="820"
           alt="You are using an outdated browser. For a faster, safer browsing experience, upgrade for free today or use other browser ,like chrome firefox safari."
           style='margin-left:auto;margin-right:auto;display: block;'/>
    </a>
  </div>
<![endif]-->
  






  <div class="container one-column page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">Tink</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu ">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div id="content" class="content"> 

  <div id="posts" class="posts-expand">
    

  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                JS模块化
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            发表于
            <time itemprop="dateCreated" datetime="2015-11-12T21:42:35+08:00" content="2015-11-12">
              2015-11-12
            </time>
          </span>

          

          
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        <span itemprop="articleBody"><blockquote class="blockquote-center"><p>JS模块化的历史演进、ES6 Module和模块管理工具</p>
</blockquote>
<p>像我这种从java入门编程的人, 在学习java的时候, 可能对模块化并没有太多的认识, 因为java中一个类一个文件, 引用其他类只需<code>import</code>导入, 结构十分清晰. 就像人每时每刻都在呼吸空气, 对空气的感觉并没有那么敏感, 直到有人抽走了他周身的空气, 他才会感觉将要窒息. 是的, 就好像我玩起了Node, 立志做个前端(此处应有表情).</p>
<p>在前端, 起初这里根本就没有什么模块化, 再后来, 我发现这里存在着各种各样的实现方法, 真是官方逼死同人哇. 这让原本习惯写后端的我感觉有些头疼, 原来我以为所有的编程语言都自带模块化标准呢.</p>
<p>“模块化Modularity”模块化显然是软件工程的概念, 就像我开头提到的, java中通过类来组织模块, 其核心就是封装-&gt;复用. 对于大型应用来说, 将整个系统拆分为不同模块, 有助于简化设计工作. 这么来看, js一开始确实没有模块化的需求, 因为原本只是在浏览器里跑两行脚本而已, 谁也没想到它竟会像今天一样变得如此复杂庞大, 以至于现在流行SPA啦, 大前端啦, 老黄历就明显不够用了. 有人说脚本语言不需要模块化, 但我接触过python, python也支持模块化, 所谓脚本语言超过1000行就没法管理了纯粹是对开发人员的鄙视, 瓦们要分清矛盾的主次.</p>
<p>那么js加上模块化就能轻松管理1000行以上的代码吗? 我想可以应该可以吧, 我写js也不久, 通过写一个Node项目给我的感觉是, 还好, 准确来说, 还挺爽的. 在NodeJS中通过在文件写一大堆类似于<code>var mongoose = require(&#39;mongoose&#39;);</code>的导入声明, 再以<code>module.exports</code>导出, 体验相对良好, 而且这属于Node的规范(下文会提到, 准确地说是实现了一部分CommonJS规范), 初学时套一套Java的做法, 并不是很难理解.</p>
<p>那么前端呢? 好消息是, ES6已经支持了类似import这样的语法, 我们应该使用babel转换器, 现在就使用它.</p>
<p>不过, 在那之前, 我们来看看, ES6之前, 大家是怎么实现模块化的. 如果你是第一次尝试模块化, 可以快速跳过AMD/CMD规范之争(即跳着看第三部分: 最近一波模块化规范), 因为他们已经过时了.</p>
<h1 id="文章的结构">文章的结构</h1><ul>
<li>模块化的好处: 为什么要模块化?</li>
<li>传统的模块化解决方案</li>
<li>最近一波模块化规范</li>
<li>ES6 Module</li>
<li>前端模块管理工具</li>
</ul>
<h1 id="模块化的好处">模块化的好处</h1><p>对应到前端, 如果前端也模块化了, 起码有这样几个好处:</p>
<ul>
<li>可重用</li>
<li>解决命名冲突的问题</li>
<li>解决繁琐的文件依赖</li>
</ul>
<h2 id="命名冲突">命名冲突</h2><p>多人团队的时候, 往往有一些个工具类, 需要用到的时候引入文件即可. 但如果现在要实现一个和工具类中同名的方法, 就会引起冲突.<br>最低级的做法, 定义一个不同的名字.</p>
<p>YUI2参考了java中<strong>命名空间</strong>的思想, 它是这样解决这个问题的:<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> com = &#123;&#125;;</span><br><span class="line">com.tinkblog = &#123;&#125;;</span><br><span class="line">com.tinkblog.utils = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">com.tinkblog.utils.getJob = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>完美地解决了冲突, 而且引起了java程序员的亲切感. 但等一段时间以后, 我们就会发现, 每次想使用这个方法, 就得记住长长的命名空间(这已经算短的了…), 比如这样:<br><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 代码来自Yahoo!</span><br><span class="line"><span class="keyword">if</span> (org.cometd.Utils.<span class="built_in">isString</span>(response)) &#123;</span><br><span class="line">  <span class="keyword">return</span> org.cometd.JSON.fromJSON(response)<span class="comment">;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (org.cometd.Utils.<span class="built_in">isArray</span>(response)) &#123;</span><br><span class="line">  <span class="keyword">return</span> response<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="文件依赖">文件依赖</h2><p>一般地, 文件之间常有依赖关系, 比如bootstrap依赖于jquery, 那么如果缺少jquery, bootstrap就会有问题<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">script</span> <span class="attribute">src</span>=<span class="value">"jquery.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">script</span> <span class="attribute">src</span>=<span class="value">"bootstrap.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>这属于众所周知的依赖, 万一是自己写的, 那就没那么容易让所有人都知道这些依赖关系啦. 而且一旦被依赖的库更新了, 依赖它的库可能都要挂掉…<br>目前在解决依赖和版本管理这个问题上, 在后端我是使用npm来管理的, 在前端则使用过一段时间的bower, 当然现在来说, bower都停止维护啦, 已经打算通过webpack+npm来管理前端的包管理.</p>
<h1 id="传统的模块化解决方案">传统的模块化解决方案</h1><p>在目前主流的模块化风格提出之前, 还有个好多种模块化方式, 出于回顾历史的需要, 不妨简单看看.</p>
<h2 id="简单地封装成一个函数">简单地封装成一个函数</h2><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">m1</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">m2</span><span class="params">()</span></span>&#123;</span><br><span class="line">　<span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种做法只是把一组变量和函数放进两个不同的函数, 利用函数作用域来形成”模块”.<br>缺点:</p>
<ul>
<li>无法保证不与其他”模块”发生变量名冲突</li>
<li>污染全局变量</li>
<li>模块成员之间缺乏联系</li>
</ul>
<h2 id="封装成一个对象">封装成一个对象</h2><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> module1 = &#123;</span><br><span class="line">  _count : <span class="number">0</span>,</span><br><span class="line">　m1 : <span class="function"><span class="keyword">function</span> <span class="params">()</span></span>&#123;</span><br><span class="line">　  <span class="comment">//...</span></span><br><span class="line">　&#125;,</span><br><span class="line">　m2 : <span class="function"><span class="keyword">function</span> <span class="params">()</span></span>&#123;</span><br><span class="line">　　<span class="comment">//...</span></span><br><span class="line">　&#125;</span><br><span class="line">&#125;;</span><br><span class="line">module1.m1();</span><br><span class="line">module2.m2();</span><br></pre></td></tr></table></figure>
<p>一个对象一个模块, 变量名不再冲突, 使用的时候, 就调用对象的属性,<br>缺点:</p>
<ul>
<li>暴露了所有模块成员, 比如外部代码可以通过module._count来改变内部计数器, 而_count一般是希望模块私有的</li>
<li>可能会使模块调用变得很长长长长长长</li>
</ul>
<h2 id="立即执行函数">立即执行函数</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> module1 = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> _count = <span class="number">0</span>;</span><br><span class="line">　<span class="keyword">var</span> m1 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">　  <span class="comment">//...</span></span><br><span class="line">　&#125;;</span><br><span class="line">　<span class="keyword">var</span> m2 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">　　<span class="comment">//...</span></span><br><span class="line">　&#125;;</span><br><span class="line">　<span class="keyword">return</span> &#123;</span><br><span class="line">　　m1 : m1,</span><br><span class="line">　　m2 : m2</span><br><span class="line">　&#125;;</span><br><span class="line">&#125;());</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(module1._count); <span class="comment">//undefined</span></span><br></pre></td></tr></table></figure>
<p>立即执行函数Immediately-Invoked Function Expression, 充分利用了函数作用域和闭包的概念, 比起简单地封装为一个对象, _count进一步变为私有成员.<br>为什么function外面还要包一层()? 因为不写的话, js会将关键字function解析为函数声明语句(参考js预编译原理), 而非函数定义表达式.</p>
<p>这种形式也是js模块化的基本写法, 受到了蝴蝶书和犀牛书的推荐, github上很多开源代码都采用了这种写法. 以下的做法都是基于它的变形.</p>
<h2 id="模块扩展augmentation">模块扩展augmentation</h2><p>一个模块继承另一个模块<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> module1 = (<span class="function"><span class="keyword">function</span> <span class="params">(mod)</span></span>&#123;</span><br><span class="line">　mod.m3 = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">　　<span class="comment">//...</span></span><br><span class="line">　&#125;;</span><br><span class="line">　<span class="keyword">return</span> mod;</span><br><span class="line">&#125;(module1));</span><br></pre></td></tr></table></figure></p>
<p>上述代码返回一个新的模块module1. 其中m3是新增的方法, 则mod是被继承的模块.</p>
<p>提到继承, 就顺便提到重载, js中通过改变加载顺序即可实现.<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> module1 = (<span class="function"><span class="keyword">function</span> <span class="params">(mod)</span></span>&#123;</span><br><span class="line">  <span class="keyword">var</span> oldM4 = mod.m4;</span><br><span class="line">　mod.m4 = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">　　<span class="comment">// 重载m4, 通过oldM4, 还可以调用旧方法</span></span><br><span class="line">　&#125;;</span><br><span class="line">　<span class="keyword">return</span> mod;</span><br><span class="line">&#125;(module1));</span><br></pre></td></tr></table></figure></p>
<p>在浏览器环境中, 各个模块通常是从网上获取的, 有时无法知道哪个部分会先加载, 则可能加载到一个undefined.<br><strong>松耦合扩展loose augmentation</strong>仅仅使用短路, 让立即执行函数的参数可以为一个空对象.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> module1 = (<span class="function"><span class="keyword">function</span> (<span class="params">mod</span>)</span>&#123;</span><br><span class="line">　mod.m3 = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">　　<span class="comment">//...</span></span><br><span class="line">　&#125;;</span><br><span class="line">　<span class="keyword">return</span> mod;</span><br><span class="line">&#125;(<span class="built_in">window</span>.module1 || &#123;&#125;));</span><br></pre></td></tr></table></figure></p>
<h2 id="引入全局变量">引入全局变量</h2><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> module1 = (<span class="function"><span class="keyword">function</span> <span class="params">($)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 在此处使用jquery对象</span></span><br><span class="line">&#125;(jQuery));</span><br></pre></td></tr></table></figure>
<p>为了在模块内调用全局变量, 必须显式地输入变量, 这种方式使得模块间的依赖关系更清晰.</p>
<p>好了, 以上回顾了传统的模块化开发方式, 即文件拆分、解决全局变量污染、命名空间和私有等等, 接下来再谈谈模块化的规范.</p>
<h1 id="最近一波模块化规范">最近一波模块化规范</h1><p>规范仅起到约束作用, 即要求大家用同样的方式编写模块, 适合开源项目或团队开发. 事实上在ES56 Module还没有出来以前, 这块是相当热闹的, 前端主要以CommonJS, AMD, CMD这三种标准为主.<br>由于我入门比较晚, 当我打算玩前端模块化的时候, 这一领域可以说几乎快要决出胜负了. 所以我对除了CommonJS以外的这些规范也只是了解而已, 并未实用, 可见的未来也应该用不上了.</p>
<h2 id="CommonJS">CommonJS</h2><p>CommonJS原来叫ServerJS, 正如其名, 由于Node.js采用并实现了部分规范, ServerJS才广泛流行.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 由于 Node 原生支持模块的作用域，并不需要额外的 wrapper</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="built_in">require</span>(<span class="string">'./a'</span>)  <span class="comment">// 加载模块（同步加载）</span></span><br><span class="line">a.doSomething()         <span class="comment">// 等上一句执行完才会执行</span></span><br><span class="line"></span><br><span class="line">exports.b = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="comment">// 暴露 b 函数接口</span></span><br><span class="line">  <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面是Node的实现, <code>exports</code>、<code>require</code>都是内置加载函数, 分别对应导出api和引入api. 使用<code>module.exports</code>直接导出一个模块(对象)</p>
<p>ServerJS大获成功, 社区希望将其推广至前端, 并改名为CommonJS. 但CommonJS存在着一些问题. 采用同步加载的机制, 这对服务器环境来说, 硬盘I/O速度不是问题, 然而放到浏览器环境, 网速就不给力了.</p>
<h2 id="分流">分流</h2><p>为了解决这个问题, 社区开始分化, 逐渐发展出三个流派, 它们分别是</p>
<ul>
<li>Modules/1.x</li>
</ul>
<p>这个观点觉得 1.x 规范已经够用, 只要移植到浏览器端就好. 要做的是新增 Modules/Transport 规范, 即在浏览器上运行前, 先通过转换工具将模块转换为符合 Transport 规范的代码.<br>主流代表是服务端的开发人员. 现在值得关注的有两个实现: 越来越火的 component 和走在前沿的 es6 module transpiler.</p>
<ul>
<li>Modules/Async</li>
</ul>
<p>这个观点觉得浏览器有自身的特征, 不应该直接用 Modules/1.x 规范.<br>典型代表是 AMD 规范及其实现 RequireJS.</p>
<ul>
<li>Modules/2.x</li>
</ul>
<p>2.x 认为也不能直接套到浏览器环境, 但应该尽可能与 Modules/1.x 规范保持一致.<br>这个观点下的典型代表是 BravoJS 和 FlyScript 的作者. BravoJS 作者对 CommonJS 的社区的贡献很大, 对 Modules/2.0-draft 规范花了很多心思. FlyScript 的作者提出了 Modules/Wrappings 规范, 这规范是 CMD 规范的前身. 后来这两人都没有继续推进这一流派, 在国外基本死得差不多了, 反而在国内有玉伯的sea.js, 虽然在我整理这篇文章的时候, 玉伯已经宣布了sea.js已死.</p>
<p>总体来看, 呈现两条主要道路, 即</p>
<ul>
<li>AMD的RequireJS: 异步加载, 预执行, 依赖前置</li>
<li>CMD的SeaJS: 异步加载, 懒执行, 依赖就近, 推荐CommonJS写法</li>
</ul>
<h2 id="AMD_&amp;_RequireJS">AMD &amp; RequireJS</h2><p>RequireJS实现了一套模块化标准, 即<code>Async Module Definition</code>, 在浏览器环境中异步加载模块. 它基本上已经成为目前的主流规范, 但是随着ES5 Module的出现, 局面也仍未定.<br>它通常长成这样:<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义calculator（计算器）模块</span></span><br><span class="line">define(</span><br><span class="line">  <span class="string">'calculator'</span>,     <span class="comment">// 可选, 模块名, 通常匿名</span></span><br><span class="line">  [<span class="string">'adder'</span>],        <span class="comment">// 可选, 模块的依赖项</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span><span class="params">(adder)</span> </span>&#123; <span class="comment">// 为模块执行初始化, 并返回具有add方法的匿名对象</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      add: <span class="function"><span class="keyword">function</span><span class="params">(n1, n2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 实际调用的是adder（加法器）模块的add方法, 而且adder模块已在前一参数['adder']中指明了</span></span><br><span class="line">        <span class="keyword">return</span> adder.add(n1, n2);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>AMD的核心是<code>define</code>函数, 这个函数用于定义一个模块, 它传入三个参数, 模块名, 依赖项和返回该模块定义的工厂函数.<br>这种风格就是AMD写法, 我们可以看到, 它是<strong>依赖前置</strong>的, 即, 要在开头就写上所有的依赖项.</p>
<p>这当然有点麻烦, 后来AMD引入了CommonJS语法糖, 可以貌似依赖就近啦.<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>([<span class="string">'math'</span>], <span class="function"><span class="keyword">function</span> <span class="params">(math)</span></span> &#123;</span><br><span class="line">  <span class="built_in">math</span>.add(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p><code>require</code>函数用于动态加载依赖项, 它的第一个参数是一个数组, 数组元素即要加载的模块. 第二个参数是一个回调, 加载模块后被执行. 模块的加载不影响它后面语句的运行, 所有依赖这个模块的语句, 都定义在一个回调函数中, 等到加载完成再执行回调.</p>
<p>它的实现其实是这样的:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">define([<span class="string">'require'</span>, <span class="string">'dependency1'</span>, <span class="string">'dependency2'</span>], <span class="function"><span class="keyword">function</span> (<span class="params">require</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> dependency1 = <span class="built_in">require</span>(<span class="string">'dependency1'</span>),</span><br><span class="line">        dependency2 = <span class="built_in">require</span>(<span class="string">'dependency2'</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>这里引出了AMD的一个问题, 即<strong>执行时机</strong>有争议.</p>
<p>在Modules/1.0中<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">var</span> <span class="tag">a</span> = <span class="function"><span class="title">require</span><span class="params">(<span class="string">"./a"</span>)</span></span> <span class="comment">// 执行到此时，a.js 才同步下载并执行</span></span><br></pre></td></tr></table></figure></p>
<p>在AMD中使用 require 的语法糖时<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">define([<span class="string">"require"</span>], <span class="function"><span class="keyword">function</span>(<span class="params">require</span>))</span>&#123;</span><br><span class="line">  <span class="comment">// 在这里，a.js 已经下载并且执行好了</span></span><br><span class="line">  <span class="comment">// 使用 require() 并不是 AMD 的推荐写法</span></span><br><span class="line">  <span class="keyword">var</span> a = <span class="built_in">require</span>(<span class="string">"./a"</span>) <span class="comment">// 此处仅仅是取模块 a 的 exports</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>AMD 里提前下载 a.js 是出于对浏览器环境的考虑, 只能采取异步下载, 这个社区都认可(Sea.js 也是这么做的).<br>但是 AMD 的执行是 <strong>预执行(Early Executing)</strong>, 而 Modules/1.0 是第一次 require 时才执行. 这个差异很多人不能接受, 包括持 Modules/2.0 观点的人也不能接受.</p>
<p>抛开require不谈, 毕竟AMD<strong>不推荐使用require</strong>. 针对预执行导致破坏依赖就近这一问题, require2.x开始思考异步处理<strong>软依赖</strong>的方案来解决<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数体内：</span></span><br><span class="line"><span class="keyword">if</span>(status)&#123;</span><br><span class="line">  <span class="keyword">async</span>([<span class="string">'a'</span>],<span class="function"><span class="keyword">function</span>(<span class="params">a</span>)</span>&#123;</span><br><span class="line">    a.doSomething()</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="CMD_&amp;_SeaJS">CMD &amp; SeaJS</h2><p>SeaJS实现了另一套模块化标准, 即<code>Common Module Definition</code>, 它也是异步加载, 但尽量遵循CommonJS的风格. 虽然这个思想不是SeaJS首先提出的, 但SeaJS之前在国内还是比较火的, 毕竟玉伯老师有淘宝光环. 但据老师本人微博(大概今年8月间), 他已经亲手给SeaJS送过丧了.</p>
<p>CMD支持的语法和CommonJS类似, 它更推荐使用<code>require</code>函数, 但是也吸收了不少AMD的思想. 比如, 根据Module/2.x的最初风格, 即 FlyScript 中的 的模块定义api 叫做 module.declare, SeaJS为了能够匹配AMD风格, 改名为 define, 传入的参数也和RequireJS相同.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params">require, exports</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="built_in">require</span>(<span class="string">'./a'</span>);   <span class="comment">// 获取模块 a 的接口</span></span><br><span class="line">  a.doSomething();          <span class="comment">// 调用模块 a 的方法</span></span><br><span class="line">  exports.foo = <span class="string">'bar'</span>;      <span class="comment">// 对外提供 foo 属性 和 doSomething 方法</span></span><br><span class="line">  exports.doSomething = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>require和exports都是全局函数, 风格与CommonJS一致.</p>
<p>比较CMD和AMD, 一大不同是CMD是<strong>依赖就近</strong>的, 因为在实现上, 它是<strong>懒执行</strong>的.<br>我们回顾下AMD的define函数:<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">define([<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>], <span class="function"><span class="keyword">function</span><span class="params">(a, b, c)</span></span>&#123;</span><br><span class="line">  <span class="comment">// 提前申明了并初始化了所有模块</span></span><br><span class="line">  <span class="literal">true</span> || b.foo(); <span class="comment">//即便根本没用到模块 b，但 b 还是提前执行了。</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>然后是CMD的:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params">require, exports, module</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="built_in">require</span>(<span class="string">'./a'</span>)</span><br><span class="line">  a.doSomething()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> b = <span class="built_in">require</span>(<span class="string">'./b'</span>) <span class="comment">// 依赖就近，延迟执行</span></span><br><span class="line">  b.doSomething()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<h2 id="UMD_&amp;_ES6_Module_Transpiler">UMD &amp; ES6 Module Transpiler</h2><p>es6 module transpiler 开发组称自己为<a href="http://zhuanlan.zhihu.com/FrontendMagazine/19569085" target="_blank" rel="external">UMD</a><code>Universal Module Definition</code>). 它希望提供一个前后端跨平台的解决方案, 同时支持CommonJS和AMD.</p>
<p>它的实现思路是这样的:</p>
<ul>
<li>先判断是否支持Node.js模块格式(exports是否存在), 存在则使用Node.js模块格式.</li>
<li>再判断是否支持AMD(define是否存在), 存在则使用AMD方式加载模块.</li>
<li>前两个都不存在，则将模块公开到全局(window或global)</li>
</ul>
<p>UMD的提出者声称, 这是对于应对规范之争的无奈之举, 写到这里, 我也感觉很无奈…</p>
<p>因为在过去几个月间, 有相当多的工具都在相继宣告go die, 以知乎等社区的推荐来看, 大家都倾向于直接使用ES6, 抛弃SeaJS(CMD)和RequireJS(AMD).</p>
<h1 id="ES6_Module">ES6 Module</h1><p>随着babel这等工具的推进, ES6的推进将比之前的版本都要快. 而且加入到语言规范中的的特性, 往往将在未来成为趋势, 所以尽快学习很有必要.</p>
<p>不过ES6 Module还在变化之中, 这里仅仅只能初涉, 具体细节等到spec确定下来, 再进一步补充完善吧.</p>
<p>ES6 Module尽量并不是UMD, 但它还是尽量在兼容现有的AMD和CommonJS模块, 支持导入这两者的模块. 它要更优雅一些, 它有所超越, 原生的语法和关键字也更方便. 最近, ES6去掉了module和loader关键字, 整体更趋向于简洁, 一个模块跟普通的脚本看起来差别不大. 你只要注意:</p>
<ul>
<li>ES6 模块<strong>自动开启严格模式</strong></li>
<li>在模块中使用import和export导入导出</li>
<li>模块中声明的任何成员都是私有的, 必须使用export来暴露它们</li>
</ul>
<h2 id="export_&amp;_import_导出和导入">export &amp; import 导出和导入</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">detectCats</span>(<span class="params">canvas, options</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> kittydar = <span class="keyword">new</span> Kittydar(options);</span><br><span class="line">  <span class="keyword">return</span> kittydar.detectCats(canvas);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">Kittydar</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 该函数未经export, 是私有的</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resizeCanvas</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="comment">//  ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>export可以添加在<code>function</code>, <code>class</code>, <code>var</code>, <code>let</code>或<code>const</code>之前. 当然, 如果觉得一一导出相当麻烦, 可以使用<strong>导出表</strong>特性, 只写一行, 导出一个变量列表:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> &#123;detectCats, Kittydar&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 尽管没有export 前缀, 依旧被导出</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">detectCats</span>(<span class="params">canvas, options</span>) </span>&#123; ... &#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Kittydar</span> </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure></p>
<p>通过一个ES6模块, 我们无需将模块内的代码放进一个立即执行函数中了. 模块不再是一个脚本文件, 它的生命周期被封装进模块作用域中, 不再会有跨文件跨模块的全局变量. 并且, 我们依旧可以访问一些基本的全局变量.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;detectCats, Kittydar&#125; <span class="keyword">from</span> <span class="string">"kittydar.js"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">go</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> canvas = <span class="built_in">document</span>.getElementById(<span class="string">"catpix"</span>);  <span class="comment">// 访问了全局变量document</span></span><br><span class="line">  <span class="keyword">var</span> cats = detectCats(canvas);</span><br><span class="line">  drawRectangles(canvas, cats);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>import导入模块, 在运行时, 被引入的模块会先被导入, 加载, 再根据依赖, 对每一个模块的内容进行深度优先遍历, 并跳过已经执行过的模块, 避免依赖循环.</p>
<h2 id="as_重命名">as 重命名</h2><p>和CommonJS一样, ES6 Module也支持允许对导入的对象重命名, 只需使用<code>as</code>关键字<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;flip <span class="keyword">as</span> flipOmelet&#125; <span class="keyword">from</span> <span class="string">"eggs.js"</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;flip <span class="keyword">as</span> flipHouse&#125; <span class="keyword">from</span> <span class="string">"real-estate.js"</span>;</span><br></pre></td></tr></table></figure></p>
<p>类似的, 导出变量也可以重命名. 这允许你将同一个值或对象以不同的变量名导出两次.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">v1</span>(<span class="params"></span>) </span>&#123; ... &#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">v2</span>(<span class="params"></span>) </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> &#123;</span><br><span class="line">  v1 <span class="keyword">as</span> streamV1,</span><br><span class="line">  v2 <span class="keyword">as</span> streamV2,</span><br><span class="line">  v2 <span class="keyword">as</span> streamLatestVersion</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="default_默认导出">default 默认导出</h2><p>理解了重命名之后, 对于导入我们还可以有一些简写, 如<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> _ <span class="keyword">from</span> <span class="string">"lodash"</span>;</span><br></pre></td></tr></table></figure></p>
<p>这等价于<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;default <span class="keyword">as</span> _&#125; <span class="keyword">from</span> <span class="string">"lodash"</span>;</span><br></pre></td></tr></table></figure></p>
<p>其中, <code>default</code>对应的是ES6模块一个默认的导出, 可以说它主要还是为了支持那些还没有ES6化的CommonJS模块, 导出它们的exports对象. 在ES6中也可以写自己的默认导出:<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">export</span> <span class="tag">default</span> &#123;</span><br><span class="line">  <span class="attribute">field1</span>: value1,</span><br><span class="line">  <span class="attribute">field2</span>: value2</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="*_模块对象">* 模块对象</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> cows <span class="keyword">from</span> <span class="string">"cows"</span>;</span><br></pre></td></tr></table></figure>
<p>通过import *, 被引入进来的是一个 <code>module namespace object</code>, 它的属性是那个模块的导出. 所以如果 “cows” 模块导出了一个名为 moo() 的函数，通过上面的那种导入方式就可以cows.moo()来调用.</p>
<h2 id="export_from_聚合模块">export from 聚合模块</h2><p>有时候一个包的主模块会引入许多其他模块, 然后再将它们以一个统一的方式导出. 为了简化这样的代码, ES6提供了 import-and-export 的简写：<br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// main.js</span><br><span class="line"><span class="keyword">export</span> &#123;<span class="type">Tea</span>, <span class="type">Cinnamon</span>&#125; <span class="keyword">from</span> <span class="string">"sri-lanka"</span>;</span><br><span class="line"><span class="keyword">export</span> &#123;<span class="type">Coffee</span>, <span class="type">Cocoa</span>&#125; <span class="keyword">from</span> <span class="string">"equatorial-guinea"</span>;</span><br><span class="line"><span class="keyword">export</span> * <span class="keyword">from</span> <span class="string">"singapore"</span>;</span><br></pre></td></tr></table></figure></p>
<p>这种 export-from 的表达式和真正的导入不同, 它有隐患. 它并不会在作用域中<strong>加入二次导出的变量绑定</strong>. 所以如果需要在 main.js 中写用到了 Tea 的代码, 就别使用这个简写形式.<br>如果 “singapore” 导出的某一个变量恰巧和其他的导出变量名冲突了, 那么这里就会出现一个错误. 所以应该谨慎使用 export *。</p>
<h2 id="模块加载的细节">模块加载的细节</h2><p>大致来说, 当 JS 引擎运行一个模块的时候, 它的行为大致可归纳为以下四步:</p>
<ul>
<li>解析: 阅读模块的源码, 并且检查是否有语法错误.</li>
<li>加载: (递归地) 加载所有被引入的模块. (  <em>还未标准化</em>  )</li>
<li>链接: 为每个新加载的模块创建一个作用域, 并且将模块中的声明绑定填入其中, 包括从其他模块中引入的.</li>
</ul>
<p>综上, 其实js引擎并不会执行import语句, 而是预编译. 模块代码运行之前, import的处理过程已经完成, 执行到一行import声明的时候, 什么也不会发生. 这意味着, <strong>ES6更倾向于AMD的预执行而不是CMD的懒执行</strong>.<br>为此, 它还有更多限制:</p>
<ul>
<li>import 和 export 只能写在顶级作用域中, 我们无法在<strong>条件语句</strong>中使用引入和导出, 也不能在<strong>自己写的函数作用域</strong>中使用import</li>
<li>所有的导出必须显示地指定一个变量名</li>
<li>无法通过一个循环动态地引入一堆变量</li>
<li>对于 import 错误, 无法在运行时进行恢复, 这导致一个应用中的任何一个加载失败或链接失败, 这个应用就不会运行. 同时无法在 try/catch 语句中 import.</li>
<li>模块无法控制它的依赖是如何被加载的, 所以无法hook一个模块, 然后在它被加载之前运行一些别的代码</li>
</ul>
<p>这一切都是因为预执行的特性, 这说明, ES6 Module是相当静态的, 这真是刷新三观哪. 但是正是基于此, 我们可以使用webpack在预处理时就检测出错误.</p>
<h1 id="前端模块管理工具">前端模块管理工具</h1><p>光有模块化, 我们还得有模块管理工具, 毕竟不同模块之间, 尤其是开源库之间, 版本管理是件麻烦事.<br>RequireJS和SeaJS各自都实现了自己的模块规范和加载器, 但还足以被称为前端模块管理器, 后者一般包括:</p>
<ul>
<li>npm + browserify</li>
<li>npm + webpack</li>
<li>bower</li>
<li>spm</li>
<li>component.js</li>
<li>duo.js</li>
</ul>
<p>下面仅对我使用过的几个简单说说.</p>
<h2 id="npm">npm</h2><p>npm属于Node模块的管理器, 支持的是CommonJS风格, 一般用于后端. 优势是库多, 应该说, 一个库一旦流行, 一定会提供npm install. 一般来说, 前端并不会直接使用npm. 而是搭配browserify一起使用.<br>browserify本身并不是一个模块管理工具, 它只是让服务器端的CommonJS格式的模块可以运行在浏览器端, 相当于间接为前端提供npm管理功能. webpack则功能更强大, 不仅能实现browserify的功能, 甚至还可以打包css, 图片等更多的资源, 和babel配合默契, 已然成为下一代主流工具.</p>
<h2 id="bower">bower</h2><p>bower是Twitter推出的包管理工具, 规范中立(UMD), 这导致它曾是最流行的前端包管理工具. 它不提供构建工具, 本质是一个静态资源的共享平台. 现在已经<strong>死啦</strong>.</p>
<p>bower与npm非常类似, 通过<code>bower i</code>来下载安装包. 比起npm和spm, bower并没有将模块发布者的文件打包保存到自己的服务器, 也没有保存模块的版本信息, 而是让发布者通过注册的形式, 公开模块可访问的git地址, 记录到bower的服务器中. 安装的过程就是根据git地址clone一份到用户本地的bower_components中.<br>bower可以通过bower.json进行版本和依赖管理, 可以通过.bowerrc文件对bower_components文件夹的位置进行指定.</p>
<h2 id="我的比较">我的比较</h2><p>对于我来说, 我一开始用的bower, 也只是做包管理, 没有进行打包的经验, bower也不提供这样的功能, 为此我不得不在index.html中写上密密麻麻的script标签来引入模块.<br>后来我接触了<strong>npm+webpack</strong>方案, 发现更合我的胃口, 因为我先玩的Node, 自然对npm和CommonJS规范感觉更亲切. 而且, 当使用Node作为后端时, 下载的包前后端通用. 开发上我用webpack进行打包, 给出一个入口文件, 不用考虑html上的script标签及其加载顺序, 那本身就已经写在了package.json中.</p>
<h1 id="总结">总结</h1><p>前端技术发展很快, 工具层出不穷, 它们往往以低廉的代价专注于某个问题域给出了当时合理的解决方案, 在短时间内成为主流, 但往往由于标准的推进, 前端问题域的变化, 落后于更好的解决方案, 迅速过时.<br>这启发我对于学习前端, 始终坚持这样一种策略:</p>
<ul>
<li>对新生工具和技术, 防御性地跟进了解, 作为技术储备</li>
<li>对主流的解决方案, 分析调研目前的需求, 快速使用, 作为开发技能</li>
<li>对过时的流行方案, 观察当时出现的背景和对应的问题域, 研究其核心思想, 作为分析参考</li>
</ul>
<p>就目前来说, 我觉得学习ES6很有必要, 这无疑是趋势, 而且现在用babel之类的转换器, 成本相当低, 带来的开发收益则很大. 但问题是, ES6的部分标准, 比如Module, 仍处于变化中, 所以并不适合大量采用.<br>2015年年末, 前端模块化的最佳实践还是npm + webpack, 即CommonJS风格. 等到Node对ES6支持得更好了, 到时再全面转过去.</p>
<h1 id="References">References</h1><ul>
<li><a href="https://github.com/seajs/seajs/issues/547" target="_blank" rel="external">前端模块化开发的价值| 玉伯</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2012/10/javascript_module.html" target="_blank" rel="external">JavaScript模块化编程| 阮一峰</a></li>
<li><a href="https://github.com/seajs/seajs/issues/588" target="_blank" rel="external">前端模块化开发那点历史| 玉伯</a></li>
<li><a href="http://huangxuan.me/2015/05/25/js-module-loader/" target="_blank" rel="external">JavaScript Module Loader</a></li>
<li><a href="http://justineo.github.io/singles/writing-modular-js/" target="_blank" rel="external">使用 AMD、CommonJS 及 ES Harmony 编写模块化的 JavaScript</a></li>
<li><a href="http://segmentfault.com/a/1190000003410285" target="_blank" rel="external">ES6 的模块系统</a></li>
<li><a href="http://zhuanlan.zhihu.com/FrontendMagazine/20238288" target="_blank" rel="external">知乎专栏: ECMAScript 6 模块架构| 来自前端外刊评论</a></li>
<li><a href="http://www.zhihu.com/question/24414899" target="_blank" rel="external">知乎: npm、spm、bower 这三个包管理器，哪个比较好用？| 来自倪云建的回答</a></li>
</ul>
<h1 id="changeLog">changeLog</h1><ul>
<li>15-11-21<br>更新了SeaJs的<a href="http://www.zhihu.com/question/34756861" target="_blank" rel="external">讣告</a><br>更新了bower的讣告</li>
<li>15-12-07<br>重写了前端模块化管理工具的部分, 去掉了没有用过的工具的过多的介绍, 将webpack写成一篇新的文章.<br>新增了ES6 Module的内容</li>
</ul>
</span>
      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/js/" rel="tag">#js</a>
          
        </div>
      

      
        <div class="post-nav">
          <div class="post-nav-prev post-nav-item">
            
              <a href="/2015/11/30/amway-gitbook/" rel="prev">
                <i class="fa fa-chevron-left"></i> Gitbook
              </a>
            
          </div>

          <div class="post-nav-next post-nav-item">
            
              <a href="/2015/10/25/js-scope/" rel="next">
                让我们一层一层地剥开作用域 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>

 </div>

        

        
          <div class="comments" id="comments">
            
          </div>
        
      </div>

      
        
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" src="https://avatars3.githubusercontent.com/u/8469791?v=3&s=460" alt="Tink" itemprop="image"/>
          <p class="site-author-name" itemprop="name">Tink</p>
        </div>
        <p class="site-description motion-element" itemprop="description">Think without help</p>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">5</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          <div class="site-state-item site-state-categories">
            
              <span class="site-state-item-count">0</span>
              <span class="site-state-item-name">分类</span>
              
          </div>

          <div class="site-state-item site-state-tags">
            <a href="/tags">
              <span class="site-state-item-count">2</span>
              <span class="site-state-item-name">标签</span>
              </a>
          </div>

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        <div class="links-of-author motion-element">
          
        </div>

      </section>

      
        <section class="post-toc-wrap motion-element sidebar-panel-active">
          <div class="post-toc-indicator-top post-toc-indicator"></div>
          <div class="post-toc">
            
            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#文章的结构"><span class="nav-number">1.</span> <span class="nav-text">文章的结构</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#模块化的好处"><span class="nav-number">2.</span> <span class="nav-text">模块化的好处</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#命名冲突"><span class="nav-number">2.1.</span> <span class="nav-text">命名冲突</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#文件依赖"><span class="nav-number">2.2.</span> <span class="nav-text">文件依赖</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#传统的模块化解决方案"><span class="nav-number">3.</span> <span class="nav-text">传统的模块化解决方案</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#简单地封装成一个函数"><span class="nav-number">3.1.</span> <span class="nav-text">简单地封装成一个函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#封装成一个对象"><span class="nav-number">3.2.</span> <span class="nav-text">封装成一个对象</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#立即执行函数"><span class="nav-number">3.3.</span> <span class="nav-text">立即执行函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#模块扩展augmentation"><span class="nav-number">3.4.</span> <span class="nav-text">模块扩展augmentation</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#引入全局变量"><span class="nav-number">3.5.</span> <span class="nav-text">引入全局变量</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#最近一波模块化规范"><span class="nav-number">4.</span> <span class="nav-text">最近一波模块化规范</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#CommonJS"><span class="nav-number">4.1.</span> <span class="nav-text">CommonJS</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#分流"><span class="nav-number">4.2.</span> <span class="nav-text">分流</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#AMD_&_RequireJS"><span class="nav-number">4.3.</span> <span class="nav-text">AMD & RequireJS</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CMD_&_SeaJS"><span class="nav-number">4.4.</span> <span class="nav-text">CMD & SeaJS</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#UMD_&_ES6_Module_Transpiler"><span class="nav-number">4.5.</span> <span class="nav-text">UMD & ES6 Module Transpiler</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#ES6_Module"><span class="nav-number">5.</span> <span class="nav-text">ES6 Module</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#export_&_import_导出和导入"><span class="nav-number">5.1.</span> <span class="nav-text">export & import 导出和导入</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#as_重命名"><span class="nav-number">5.2.</span> <span class="nav-text">as 重命名</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#default_默认导出"><span class="nav-number">5.3.</span> <span class="nav-text">default 默认导出</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#*_模块对象"><span class="nav-number">5.4.</span> <span class="nav-text">* 模块对象</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#export_from_聚合模块"><span class="nav-number">5.5.</span> <span class="nav-text">export from 聚合模块</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#模块加载的细节"><span class="nav-number">5.6.</span> <span class="nav-text">模块加载的细节</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#前端模块管理工具"><span class="nav-number">6.</span> <span class="nav-text">前端模块管理工具</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#npm"><span class="nav-number">6.1.</span> <span class="nav-text">npm</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#bower"><span class="nav-number">6.2.</span> <span class="nav-text">bower</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#我的比较"><span class="nav-number">6.3.</span> <span class="nav-text">我的比较</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#总结"><span class="nav-number">7.</span> <span class="nav-text">总结</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#References"><span class="nav-number">8.</span> <span class="nav-text">References</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#changeLog"><span class="nav-number">9.</span> <span class="nav-text">changeLog</span></a></li></ol></div>
            
          </div>
          <div class="post-toc-indicator-bottom post-toc-indicator"></div>
        </section>
      

    </div>
  </aside>


      
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner"> <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="icon-next-heart fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Tink</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT
  </a>
</div>


 </div>
    </footer>

    <div class="back-to-top"></div>
  </div>

  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  
  
    
    

  


  
  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js"></script>
  <script type="text/javascript" src="/js/fancy-box.js?v=0.4.5.2"></script>


  <script type="text/javascript" src="/js/helpers.js?v=0.4.5.2"></script>
  

  <script type="text/javascript" src="/vendors/velocity/velocity.min.js"></script>
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js"></script>

  <script type="text/javascript" src="/js/motion_global.js?v=0.4.5.2" id="motion.global"></script>




  <script type="text/javascript" src="/js/nav-toggle.js?v=0.4.5.2"></script>
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  
<script type="text/javascript" src="/js/bootstrap.scrollspy.js?v=0.4.5.2" id="bootstrap.scrollspy.custom"></script>


<script type="text/javascript" id="sidebar.toc.highlight">
  $(document).ready(function () {
    var tocSelector = '.post-toc';
    var $tocSelector = $(tocSelector);
    var activeCurrentSelector = '.active-current';

    $tocSelector
      .on('activate.bs.scrollspy', function () {
        var $currentActiveElement = $(tocSelector + ' .active').last();

        removeCurrentActiveClass();
        $currentActiveElement.addClass('active-current');

        $tocSelector[0].scrollTop = $currentActiveElement.position().top;
      })
      .on('clear.bs.scrollspy', function () {
        removeCurrentActiveClass();
      });

    function removeCurrentActiveClass () {
      $(tocSelector + ' ' + activeCurrentSelector)
        .removeClass(activeCurrentSelector.substring(1));
    }

    function processTOC () {
      getTOCMaxHeight();
      toggleTOCOverflowIndicators();
    }

    function getTOCMaxHeight () {
      var height = $('.sidebar').height() -
                   $tocSelector.position().top -
                   $('.post-toc-indicator-bottom').height();

      $tocSelector.css('height', height);

      return height;
    }

    function toggleTOCOverflowIndicators () {
      tocOverflowIndicator(
        '.post-toc-indicator-top',
        $tocSelector.scrollTop() > 0 ? 'show' : 'hide'
      );

      tocOverflowIndicator(
        '.post-toc-indicator-bottom',
        $tocSelector.scrollTop() >= $tocSelector.find('ol').height() - $tocSelector.height() ? 'hide' : 'show'
      )
    }

    $(document).on('sidebar.motion.complete', function () {
      processTOC();
    });

    $('body').scrollspy({ target: tocSelector });
    $(window).on('resize', function () {
      if ( $('.sidebar').hasClass('sidebar-active') ) {
        processTOC();
      }
    });

    onScroll($tocSelector);

    function onScroll (element) {
      element.on('mousewheel DOMMouseScroll', function (event) {
          var oe = event.originalEvent;
          var delta = oe.wheelDelta || -oe.detail;

          this.scrollTop += ( delta < 0 ? 1 : -1 ) * 30;
          event.preventDefault();

          toggleTOCOverflowIndicators();
      });
    }

    function tocOverflowIndicator (indicator, action) {
      var $indicator = $(indicator);
      var opacity = action === 'show' ? 0.4 : 0;
      $indicator.velocity ?
        $indicator.velocity('stop').velocity({
          opacity: opacity
        }, { duration: 100 }) :
        $indicator.stop().animate({
          opacity: opacity
        }, 100);
    }

  });
</script>

<script type="text/javascript" id="sidebar.nav">
  $(document).ready(function () {
    var html = $('html');
    var TAB_ANIMATE_DURATION = 200;
    var hasVelocity = $.isFunction(html.velocity);

    $('.sidebar-nav li').on('click', function () {
      var item = $(this);
      var activeTabClassName = 'sidebar-nav-active';
      var activePanelClassName = 'sidebar-panel-active';
      if (item.hasClass(activeTabClassName)) {
        return;
      }

      var currentTarget = $('.' + activePanelClassName);
      var target = $('.' + item.data('target'));

      hasVelocity ?
        currentTarget.velocity('transition.slideUpOut', TAB_ANIMATE_DURATION, function () {
          target
            .velocity('stop')
            .velocity('transition.slideDownIn', TAB_ANIMATE_DURATION)
            .addClass(activePanelClassName);
        }) :
        currentTarget.animate({ opacity: 0 }, TAB_ANIMATE_DURATION, function () {
          currentTarget.hide();
          target
            .stop()
            .css({'opacity': 0, 'display': 'block'})
            .animate({ opacity: 1 }, TAB_ANIMATE_DURATION, function () {
              currentTarget.removeClass(activePanelClassName);
              target.addClass(activePanelClassName);
            });
        });

      item.siblings().removeClass(activeTabClassName);
      item.addClass(activeTabClassName);
    });

    $('.post-toc a').on('click', function (e) {
      e.preventDefault();
      var targetSelector = escapeSelector(this.getAttribute('href'));
      var offset = $(targetSelector).offset().top;
      hasVelocity ?
        html.velocity('stop').velocity('scroll', {
          offset: offset  + 'px',
          mobileHA: false
        }) :
        $('html, body').stop().animate({
          scrollTop: offset
        }, 500);
    });

    // Expand sidebar on post detail page by default, when post has a toc.
    var $tocContent = $('.post-toc-content');
    if (isDesktop() && CONFIG.sidebar === 'post') {
      if ($tocContent.length > 0 && $tocContent.html().trim().length > 0) {
        displaySidebar();
      }
    }
  });
</script>



  <script type="text/javascript">
    $(document).ready(function () {
      if (CONFIG.sidebar === 'always') {
        displaySidebar();
      }
      if (isMobile()) {
        FastClick.attach(document.body);
      }

      motionIntegrator.bootstrap();
    });
  </script>

  
  

  
  

  
  <script type="text/javascript" src="/js/lazyload.js"></script>
  <script type="text/javascript">
    $(function () {
      $("#posts").find('img').lazyload({
        placeholder: "/images/loading.gif",
        effect: "fadeIn"
      });
    });
  </script>
</body>
</html>
